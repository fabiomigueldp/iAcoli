<!DOCTYPE html>
<html lang="pt-BR" data-theme="light">
<head>
  <meta charset="utf-8" />
  <title>Acoli</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <!-- Fontes para estilo missal romano/medieval -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700;900&family=Cinzel+Decorative:wght@400;700;900&display=swap" rel="stylesheet">

  <!-- rrule + FullCalendar -->
  <script src="https://cdn.jsdelivr.net/npm/rrule@2.8.1/dist/es5/rrule.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.19/index.global.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fullcalendar/core@6.1.19/locales-all.global.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fullcalendar/rrule@6.1.19/index.global.min.js"></script>
  
  <!-- Floating UI (UMD): core primeiro, depois dom -->
  <script src="https://cdn.jsdelivr.net/npm/@floating-ui/core@1.6.9"></script>
  <script src="https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.6.11"></script>

  <style>
    /* ========= Design tokens (tema claro, sóbrio) ========= */
    :root{
      /* Papel & tintas */
      --page-cream: #fbf7ef;          /* "papel creme" */
      --page-ink: #1c1a17;            /* texto principal (preto quente) */
      --page-ink-weak: #3a362f;       /* subtítulos/UI */
      --parchment: #fffdf7;           /* cartões/balões */

      /* Rubricas e douração */
      --rubric: #7f0d10;              /* vermelho profundo acessível */
      --rubric-weak: #a11c1f;
      --gilded: #c7a760;              /* dourado discreto */
      --hairline: #e2d7c1;            /* filete editorial */

      /* Paleta litúrgica (accents) */
      --season-green: #2e5b34;        /* Tempo Comum */
      --season-violet: #4b2c5f;       /* Advento/Quaresma */
      --season-red: #8a0f0f;          /* Pentecostes/Mártires/Paixão */
      --season-white: #bda46e;        /* branco "dourado" */
      --season-rose: #b86b7e;         /* Gaudete/Laetare */
      --season-black: #2b2b2b;        /* Exéquias */

      /* Accent ativo (iniciado em verde) */
      --accent: var(--season-green);
      --accent-50: color-mix(in srgb, var(--accent), #fff 90%);
      --accent-ink: color-mix(in srgb, var(--accent), #000 30%);

      /* Superfícies (derivadas dos tons "papel") */
      --bg: var(--page-cream);
      --surface: var(--parchment);
      --surface-2: #fffaf2;
      --border: var(--hairline);
      --text: var(--page-ink);
      --muted: var(--page-ink-weak);
      --muted-2: #6b6a64;

      /* Estados adaptados ao esquema Missal */
      --ok: #2f6d44;     --ok-bg: #edf7f1;
      --warn: #8a6a1f;   --warn-bg: #f9f5e6;
      --danger: var(--rubric); --danger-bg: #fff2f2;

      /* Tipografia & ritmo */
      --radius: 12px;
      --shadow-1: 0 1px 2px rgba(0,0,0,.06);
      --shadow-2: 0 6px 18px rgba(0,0,0,.07);
      --font: 16px/1.6 "Georgia","Garamond","Palatino","Times New Roman",serif;
      --h1: 18px;
      --space-1: 6px; --space-2: 10px; --space-3: 14px; --space-4: 18px;
    }

    .alto-contraste{
      --page-cream: #fffef9;
      --page-ink: #111;
      --rubric: #6b0000;
      --hairline: #d9ccb2;
      --gilded: #a98a44;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--text); font:var(--font);
      display:flex; flex-direction:column;
      background:
        radial-gradient(1200px 800px at 120% -10%, rgba(199,167,96,.12), transparent 60%),
        radial-gradient(1000px 600px at -20% 110%, rgba(126,86,40,.06), transparent 60%),
        var(--bg);
    }

    /* Cabeçalho com dupla linha dourada + sombra rubra sutil */
    header{
      position:sticky; top:0; z-index:10;
      background:linear-gradient(to bottom, rgba(255,255,255,.7), rgba(255,255,255,.3)), var(--surface);
      border-bottom:3px double var(--gilded);
      box-shadow:0 2px 0 var(--rubric-weak);
      padding: var(--space-3) var(--space-4);
      display:flex; align-items:center; justify-content:space-between; gap: var(--space-3);
    }
    /* ---------- HEADER: título com capitular dinâmica ---------- */
    header h1{
      font-size:var(--h1);
      margin:0;
      font-weight:800;
      letter-spacing:.02em;
      font-variant:small-caps;
    }
    header h1::first-letter{
      font-size:1.9em;
      line-height:.8;
      color:var(--accent);
      margin-right:2px;
      font-weight:900;
    }

    /* Fitilho sazonal logo abaixo do header */
    .season-ribbon{
      height:6px; width:100%;
      background: linear-gradient(90deg, var(--accent), color-mix(in srgb, var(--accent), #000 20%));
      border-top:1px solid color-mix(in srgb, var(--accent), #fff 40%);
      border-bottom:1px solid color-mix(in srgb, var(--accent), #000 25%);
      box-shadow:0 1px 0 #fff, 0 2px 0 rgba(0,0,0,.05) inset;
    }

    /* Painéis como fólios */
    .panel{
      background:var(--surface);
      border:1px solid var(--border);
      border-radius:var(--radius);
      min-height:0; display:flex; flex-direction:column; overflow:hidden;
      box-shadow: var(--shadow-2);
    }
    .panel .title{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      color:var(--muted);
      font-weight:700; letter-spacing:.02em; font-variant:small-caps;
    }

    /* Botões com caráter clássico */
    .btn{
      border:1px solid var(--border);
      background:var(--surface);
      color:var(--text);
      padding:8px 12px; border-radius:10px; cursor:pointer; font-weight:700;
      box-shadow:var(--shadow-1);
    }
    .btn.primary{
      background:linear-gradient(180deg, color-mix(in srgb, var(--accent), #fff 60%), var(--accent));
      color:#fff; border-color:color-mix(in srgb, var(--accent), #000 35%);
      text-shadow:0 1px 0 rgba(0,0,0,.25);
    }
    .btn.danger{ background: var(--danger-bg); border-color: var(--danger); color: var(--rubric); }
    .btn.ghost{ background:transparent }
    .btn.mini{ padding:6px 10px; font-size:13px }

    /* CHAT — rubricas, proclamações, capitular, meta em versaletes */
    #messages{ background:var(--surface); }
    .bubble{
      max-width:92%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:#fff;
      box-shadow:var(--shadow-1);
    }
    /* fitilho lateral de cada lado */
    .bubble.bot { align-self:flex-start; border-left:4px solid var(--accent); }
    .bubble.user{ align-self:flex-end; border-left:4px solid color-mix(in srgb, var(--accent), #000 25%); background:#f3f4f6; }

    .meta{
      font-size:12px; color:var(--muted); margin-bottom:6px;
      font-variant: small-caps; letter-spacing:.04em;
    }
    .rubric{ color:var(--rubric); font-style:italic; }
    .proclamation{ color:var(--text); }
    .antiphon{ padding-left:18px; text-indent:-18px; }
    .antiphon::before{ content:"R/ "; color:var(--muted); font-variant:small-caps; letter-spacing:.04em; }
    .dropcap:first-letter{
      float:left; font-size:3.1em; line-height:.82; padding-right:.08em; margin-top:.02em;
      color: color-mix(in srgb, var(--accent), #000 20%); font-weight:700;
    }

    /* texto interno pode quebrar normalmente */
    .bubble .proclamation,
    .bubble .rubric,
    .bubble .antiphon { white-space: normal; }

    /* Campos, barras e focos coerentes */
    .field{ background:var(--surface-2); border:1px solid var(--border); }
    .inputRow{ background:var(--surface-2); border-top:1px solid var(--border); }
    :focus-visible{ outline:2px solid color-mix(in oklab, var(--accent) 55%, transparent); outline-offset:2px; }

    /* TOAST em chave verde/rubra */
    .toast{ background:#fff; color:var(--text); border-left:4px solid var(--ok); border:1px solid var(--border); }
    .toast.err{ border-left-color: var(--rubric); background: var(--danger-bg); }

    /* CALENDÁRIO — cartões com duas tintas e seleção em dourado */
    .event-card{
      background:#fffdfa;
      border:1px solid var(--border);
      border-radius:10px;
      box-shadow: var(--shadow-1);
    }
    .event-card .event-title{ color:var(--text); font-weight:700; }
    .event-card .event-meta{ color:var(--muted); }
    .fc-event.is-selected .event-card{
      border-color: var(--gilded);
      box-shadow: 0 0 0 2px rgba(199,167,96,.35);
    }

    /* FullCalendar em chave Missal */
    .fc .fc-toolbar-title{ font-size:14px; font-weight:700; color:var(--text); font-variant:small-caps; }
    .fc .fc-button{
      background:#fff; border:1px solid var(--border); color:var(--text); border-radius:8px; padding:5px 10px;
    }
    .fc .fc-button-primary:hover{
      background:var(--surface-2); border-color:var(--border); color:var(--text);
    }
    .fc-theme-standard td, .fc-theme-standard th{ border-color:var(--border) }
    .fc .fc-daygrid-day-number{ color:var(--muted); font-weight:600 }
    .fc .fc-col-header-cell-cushion{ color:var(--muted); }
    .fc .fc-day-today{ background: color-mix(in srgb, var(--accent), #fff 85%) !important }

    /* Popover do dia com "pergaminho" */
    .day-overlay{
      background:var(--surface);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow:0 4px 20px rgba(0,0,0,.15);
    }
    .day-overlay-item:hover{
      border-color: color-mix(in srgb, var(--accent), #000 20%);
      background: color-mix(in srgb, var(--accent), #fff 90%);
    }

    /* Filetes em dourado sob títulos principais (opcional) */
    .panel .title{ border-bottom:3px double var(--gilded); box-shadow: 0 1px 0 var(--rubric-weak); }

    /* ========= Chat ========= */
    #chat{display:flex; flex-direction:column; height:100%}
    #messages{
      flex:1; overflow:auto; padding: var(--space-3); display:flex; flex-direction:column; gap: var(--space-2);
      scrollbar-width: thin; scrollbar-color: #d6d8dd transparent;
      background:var(--surface);
    }
    #messages::-webkit-scrollbar{ width:10px }
    #messages::-webkit-scrollbar-track{ background:transparent }
    #messages::-webkit-scrollbar-thumb{ background:#d6d8dd; border:2px solid transparent; background-clip:padding-box; border-radius:999px }

    .meta{ font-size:11px; color:var(--muted); margin-bottom:6px }

    .inputRow{
      display:flex; gap:8px; padding:10px; border-top:1px solid var(--border); background:var(--surface-2)
    }
    .inputRow textarea{
      flex:1; resize:none; min-height:54px; max-height:120px; padding:10px; border-radius:10px; border:1px solid var(--border); outline:none;
      background:#fff; color:var(--text); font:inherit; scrollbar-width:none; -ms-overflow-style:none;
    }
    .inputRow textarea::placeholder{
      white-space:normal;
    }
    .inputRow textarea::-webkit-scrollbar{ display:none }

    /* ========= Calendário ========= */
    .calendar-panel{display:flex; flex-direction:column;}

    #calendar{
      min-height:420px;
      background: var(--surface);
      border-radius: var(--radius);
      border:1px solid var(--border);
      overflow:hidden;
      position:relative;
    }
    #eventDetails{
      background: var(--surface-2);
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding: var(--space-3);
      display:flex;
      flex-direction:column;
      gap: var(--space-2);
      min-height:0;
      overflow:auto;
    }
    #eventDetails .event-details-empty{
      text-align:center;
      color: var(--muted);
      margin:auto;
      font-size:13px;
      max-width:220px;
    }
    .event-details-content{
      display:flex;
      flex-direction:column;
      gap: var(--space-2);
    }
    .event-details-head h2{
      margin:0;
      font-size:16px;
      line-height:1.35;
      display:-webkit-box;
      -webkit-line-clamp:2;
      line-clamp: 2;
      -webkit-box-orient:vertical;
      overflow:hidden;
      text-overflow:ellipsis;
      text-transform:none;
    }
    .event-details-time{
      font-size:13px;
      color: var(--muted);
      text-transform:none;
      line-height:1.4;
      display:-webkit-box;
      -webkit-line-clamp:2;
      line-clamp: 2;
      -webkit-box-orient:vertical;
      overflow:hidden;
    }
    .event-details-meta{
      font-size:13px;
      color: var(--text);
      background:var(--surface);
      border:1px solid var(--border);
      border-radius: var(--radius);
      padding:10px 12px;
      position:relative;
    }
    .event-details-meta::before{
      content: attr(data-label);
      display:block;
      font-size:11px;
      font-weight:600;
      text-transform:none;
      letter-spacing:.02em;
      color: var(--muted);
      margin-bottom:4px;
    }
    .event-details-acolytes-title{
      font-weight:700;
      font-size:13px;
      color: var(--accent-ink);
    }
    .acolyte-list{
      list-style:none;
      padding:0;
      margin:0;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .acolyte-item{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: var(--space-2);
      padding:8px 10px;
      background:var(--surface);
      border:1px solid var(--border);
      border-radius: var(--radius);
      font-size:13px;
    }
    .acolyte-item .acolyte-role{
      font-weight:600;
      color: var(--accent-ink);
    }
    .acolyte-item .acolyte-name{
      font-weight:500;
      color: var(--text);
    }
    .acolyte-item.empty{
      color: var(--muted);
      justify-content:center;
    }
    .details-actions{
      display:flex;
      gap: var(--space-2);
      margin-top:auto;
    }
    .fc-event.is-selected .event-card{
      border-color: var(--accent);
      box-shadow:0 0 0 2px rgba(58,92,204,.18);
    }
    @media (max-width: 1100px){
      .calendarShell{
        grid-template-columns:1fr;
      }
      #eventDetails{
        order:2;
      }
    }
    /* FullCalendar: tema neutro e coerente */
    .fc .fc-toolbar-title{ font-size:14px; font-weight:700; color:var(--text); font-variant:small-caps; }
    .fc .fc-button{
      background:#fff; border:1px solid var(--border); color:var(--text); border-radius:8px; padding:5px 10px;
    }
    .fc .fc-button-primary:not(:disabled).fc-button-active,
    .fc .fc-button-primary:not(:disabled):active,
    .fc .fc-button-primary:hover{
      background:var(--surface-2); border-color:var(--border); color:var(--text);
    }
    .fc-theme-standard td, .fc-theme-standard th{ border-color:var(--border) }
    .fc .fc-daygrid-day-number{ color:var(--muted); font-weight:600 }
    .fc .fc-col-header-cell-cushion{ color:var(--muted); }
    .fc .fc-day-today{ background: color-mix(in srgb, var(--accent), #fff 85%) !important }

    /* ========= details/sources ========= */
    details{margin-top:8px; border-top:1px dashed var(--border); padding-top:8px}
    details summary{cursor:pointer; color:var(--accent-ink); font-size:12px}
    details pre{background:#fafafa; border:1px solid var(--border); border-radius:8px; padding:10px; overflow:auto}
    code, pre code{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px}
    code.inline{background:#f3f4f6; border:1px solid var(--border); border-radius:6px; padding:2px 5px}
    .sources{margin-top:8px; font-size:12px; color:var(--muted)}
    .sources a{color:var(--accent-ink); text-decoration:underline}

    .slot-list{display:flex; flex-wrap:wrap; gap:6px; margin-top:8px}
    .slot{padding:6px 8px; border-radius:8px; border:1px solid var(--border); font-size:12px; background:#fff}

    /* ========= Toast ========= */
    .toast{
      position:fixed; right:14px; bottom:14px; background:#fff; color:var(--accent-ink);
      padding:10px 12px; border:1px solid var(--border); border-left:4px solid var(--ok);
      border-radius:10px; display:none; z-index:20; box-shadow:var(--shadow-2)
    }
    .toast.err{ border-left-color: var(--danger); background: var(--danger-bg) }

    /* ========= Acessibilidade: focos consistentes ========= */
    .btn:focus-visible,
    .field input:focus-visible,
    .field select:focus-visible,
    .inputRow textarea:focus-visible{
      outline:2px solid color-mix(in oklab, var(--accent) 55%, transparent); outline-offset:2px;
    }

    .visually-hidden{position:absolute!important;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0 0 0 0);white-space:nowrap;border:0}

    main{
      display: grid;
      grid-template-columns: 1fr 2fr 1fr;
      gap: var(--space-3);
      padding: var(--space-3);
      min-height: calc(100vh - 120px); /* considerando header e ribbon */
    }
    .modal{
      position:fixed; top:0; left:0; width:100%; height:100%;
      background:rgba(0,0,0,.5); z-index:1000;
      display:flex; align-items:center; justify-content:center;
      opacity:0; visibility:hidden; transition:opacity 0.2s ease, visibility 0.2s ease;
    }
    .modal.open{
      opacity:1; visibility:visible;
    }
    /* ---------- MODAL (layout mais limpo e preciso) ---------- */
    .modal-content{
      max-width:720px; /* mais confortável */
      width:92%;
      max-height:82vh;
      overflow:auto;
      background:var(--surface);
      border-radius:calc(var(--radius) + 2px);
      box-shadow:0 18px 45px rgba(0,0,0,.25);
      border:1px solid var(--border);
    }
    .modal-header{
      display:flex; justify-content:space-between; align-items:center;
      padding: 14px 18px;
      border-bottom:1px solid var(--border);
    }
    .modal-header h2{
      margin:0; font-size:16px; font-weight:800; letter-spacing:.02em; font-variant:small-caps;
    }
    .modal-body{
      padding: var(--space-4);
      display:flex; flex-direction:column; gap: var(--space-3);
    }
    .modal-actions{
      display:flex; gap: var(--space-2); justify-content:flex-start;
    }

    /* ===== POPUP de "Eventos do dia" (substitui o popover padrão do FC) ===== */
    :root{
      /* camada acima do header (10) e do toast (20), mas abaixo dos modais (1000) */
      --z-popover: 60;
    }

    .day-overlay{
      position: fixed; /* já é setado em JS, repetimos por segurança */
      inset: auto auto auto auto; /* neutral */
      z-index: var(--z-popover);
      background: var(--surface);               /* fundo opaco */
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: 0 12px 30px rgba(0,0,0,.18), 0 2px 6px rgba(0,0,0,.08);
      width: 280px; /* JS ajusta com Floating UI; aqui é mínimo seguro */
      overflow: hidden; /* para o cabeçalho fixo */
    }

    .day-overlay[hidden]{ display:none !important; }

    .day-overlay-head{
      display:flex; align-items:center; justify-content:space-between;
      gap: 8px;
      position: sticky; top:0;
      background: var(--surface);
      padding: 10px 12px;
      border-bottom: 1px solid var(--border);
    }

    .day-overlay-date{
      font-weight: 700; font-size: 13px;
      color: var(--accent-ink);
    }

    .day-overlay-close{
      appearance: none; border:0; background: transparent;
      font-size: 20px; line-height: 1; cursor: pointer; color: var(--muted);
      border-radius: 8px; padding: 2px 6px;
    }
    .day-overlay-close:hover,
    .day-overlay-close:focus-visible{
      background: color-mix(in srgb, var(--accent), #fff 90%);
      outline: 2px solid color-mix(in oklab, var(--accent) 55%, transparent);
      outline-offset: 2px;
    }

    .day-overlay-list{
      max-height: 320px; /* será refinado pelo FloatingUI.size() */
      overflow: auto;
      padding: 8px;
      display:flex; flex-direction:column; gap: 8px;
    }

    .day-overlay-item{
      display:block; width:100%; text-align:left;
      background: #fff; color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      cursor: pointer;
      min-height: 44px; /* alvo de toque/acessibilidade */
      box-shadow: var(--shadow-1);
    }
    .day-overlay-item .item-title{ font-weight:700; font-size: 13px; }
    .day-overlay-item .item-meta{ font-size:12px; color: var(--muted); margin-top:2px; }
    .day-overlay-item .item-foot{ font-size:12px; color: var(--muted-2); margin-top:4px; }

    .day-overlay-item:hover,
    .day-overlay-item:focus-visible{
      border-color: color-mix(in srgb, var(--accent), #000 20%);
      background: color-mix(in srgb, var(--accent), #fff 90%);
      outline: 2px solid color-mix(in oklab, var(--accent) 55%, transparent);
      outline-offset: 2px;
    }

    .day-overlay-item:active{ transform: translateY(1px); }

    /* realce da célula do dia quando o popover está aberto */
    .day-overlay-target{
      outline: 2px solid color-mix(in oklab, var(--accent) 55%, transparent);
      outline-offset: -2px;
      border-radius: 6px;
    }

    /* (opcional) garanta que o link "+N mais" fique acima do conteúdo da célula */
    .fc-daygrid-more-link{ position: relative; z-index: calc(var(--z-popover) + 1); }

    /* === Estado de digitação (streaming) === */
    .bubble.bot.is-typing .typing-line{
      display:inline-flex; gap:4px; align-items:center;
      padding:4px 0;
    }
    .typing-dot{
      width:6px; height:6px; border-radius:999px; background: var(--muted);
      display:inline-block; animation: dotPulse 1.2s infinite ease-in-out;
    }
    .typing-dot:nth-child(2){ animation-delay:.2s }
    .typing-dot:nth-child(3){ animation-delay:.4s }
    @keyframes dotPulse{
      0%, 60%, 100% { transform: translateY(0); opacity:.6 }
      30% { transform: translateY(-3px); opacity:1 }
    }

    /* === Progresso de ações (criar/editar/remover) === */
    .action-progress{
      margin-top:8px; background: var(--surface); border:1px solid var(--border);
      border-left:4px solid var(--gilded); border-radius:10px; padding:10px 12px;
      box-shadow: var(--shadow-1);
    }
    .action-progress-head{
      font-size:12px; color:var(--muted); margin-bottom:6px; font-variant: small-caps; letter-spacing:.04em;
    }
    .action-progress-bar{
      height:6px; background: #f5efe1; border-radius:999px; overflow:hidden; position:relative;
      box-shadow: inset 0 1px 2px rgba(0,0,0,.06);
    }
    .action-progress-bar .fill{
      height:100%; width:0%;
      background: linear-gradient(90deg, var(--gilded), color-mix(in srgb, var(--gilded), #000 20%));
      transition: width .35s ease;
    }
    .action-progress.done{
      border-left-color: var(--ok);
    }
    .action-progress.done .action-progress-head::after{
      content:" ✓";
      color: var(--ok);
    }

    /* === Mini shimmer para placeholders (opcional) === */
    .shimmer{
      position:relative; overflow:hidden; background: #fff;
    }
    .shimmer::after{
      content:""; position:absolute; inset:0 -150%; transform: translateX(-100%);
      background: linear-gradient(90deg, transparent, rgba(255,255,255,.6), transparent);
      animation: shimmer 1.2s infinite;
    }
    @keyframes shimmer{ 100% { transform: translateX(100%)} }

    /* ---------- “Marca” dentro do modal (sem balão) ---------- */
    .modal-brand{
      margin: 16px 0 24px 0;
      padding: 20px;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow-1);
      text-align: center;
    }

    
    .modal-brand .main-title {
      font-family: "Cinzel", "Times New Roman", serif;
      font-size: 26px;
      font-weight: 800;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--rubric);
      line-height: 1;
      margin: 0 8px;
    }
    
    .modal-brand .liturgical-frame {
      display: inline-flex;
      align-items: center;
      margin-bottom: 12px;
      padding: 6px 12px;
      border: 2px solid var(--gilded);
      border-radius: 6px;
      background: rgba(199,167,96,0.03);
    }
    
    .modal-brand .alpha-omega-symbol {
      font-family: "Times New Roman", serif;
      font-size: 18px;
      font-weight: 700;
      color: var(--gilded);
      opacity: 0.85;
      line-height: 1;
    }
    
    .modal-brand .subtitle {
      font-family: "Times New Roman", serif;
      font-size: 11px;
      font-variant: small-caps;
      letter-spacing: 0.04em;
      color: var(--muted);
      margin-top: 8px;
      line-height: 1.4;
      max-width: 300px;
      margin-left: auto;
      margin-right: auto;
    }
    
    /* Versões responsivas para escalabilidade */
    @media (max-width: 600px) {
      .modal-brand .main-title {
        font-size: 22px;
        letter-spacing: 0.1em;
      }
      .modal-brand .alpha-omega-symbol {
        font-size: 16px;
      }
      .modal-brand .subtitle {
        font-size: 10px;
        max-width: 280px;
      }
    }
    
    /* Versão para contextos muito pequenos */
    @media (max-width: 400px) {
      .modal-brand {
        padding: 16px;
      }
      .modal-brand .liturgical-frame {
        padding: 4px 8px;
      }
      .modal-brand .main-title {
        font-size: 20px;
        letter-spacing: 0.08em;
      }
      .modal-brand .alpha-omega-symbol {
        font-size: 14px;
      }
    }
    
    /* Versão monocromática (para impressão) */
    @media print {
      .modal-brand .liturgical-frame {
        border-color: #333;
        background: transparent;
      }
      .modal-brand .alpha-omega-symbol,
      .modal-brand .main-title {
        color: #333 !important;
      }
      .modal-brand .subtitle {
        color: #666 !important;
      }
    }

    /* Ajuda/hints dos campos */
    .hint{ font-size:12px; color:var(--muted); margin-top:4px; }

    /* Layout agradável para grupos de opções */
    .options-grid{ display:grid; grid-template-columns:1fr; gap:12px; }
    @media (min-width:600px){ .options-grid{ grid-template-columns:1fr 1fr; } }

    .card{ background:var(--surface); border:1px solid var(--border); border-radius:var(--radius); padding:12px; box-shadow:var(--shadow-1); }
    .card h3{ margin:0 0 6px 0; font-size:13px; color:var(--accent-ink); }

    /* Manual enxuto */
    .manual{ font-size:12px; color:var(--muted); border-top:1px dashed var(--border); padding-top:10px; }
    .manual code{ font-size:12px; }

    /* FullCalendar: daygrid overflow hidden para evitar sobreposição */
    .fc-daygrid-day-events{ overflow:hidden; padding-bottom:20px; }

    /* "+N more" chip posicionado corretamente */
    .fc-daygrid-more-link{
      position:absolute; top:2px; left:2px;
      background:var(--accent); color:#fff; border-radius:12px; padding:2px 6px;
      font-size:11px; font-weight:600; text-decoration:none;
      box-shadow:0 1px 3px rgba(0,0,0,.2);
      z-index:1;
    }
  </style></head>
<body>
  <header aria-label="Barra superior">
    <h1>Acoli</h1>
    <button id="optionsBtn" class="btn mini" type="button" title="Abrir opções">⚙️ Opções</button>
  </header>

  <div class="season-ribbon" aria-hidden="true"></div>

  <main>
    <section class="panel" id="chat" aria-label="Chat">
      <div class="title"><span>Chat — Acoli</span></div>
      <div id="messages" aria-live="polite" aria-atomic="false"></div>
      <div class="inputRow">
        <label for="input" class="visually-hidden" aria-hidden="true">Mensagem</label>
        <textarea
          id="input"
          placeholder="Ex.: Dom 19:30 — Missa na Matriz. LIB: João; CRU: Ana"
          aria-label="Mensagem para o Acoli">
        </textarea>
        <button id="send" class="btn primary" type="button">Enviar</button>
      </div>
    </section>

    <section class="panel calendar-panel" aria-label="Calendário">
      <div class="title">Calendário</div>
      <div id="calendar" aria-label="Agenda"></div>
    </section>

    <aside id="eventDetails" aria-live="polite" class="panel">
      <div class="event-details-empty" role="note">Selecione uma missa no calendário.</div>
      <div class="event-details-content" hidden>
        <div class="event-details-head">
          <h2 id="detailTitle">Missa</h2>
          <div class="event-details-time" id="detailTime"></div>
        </div>
        <div class="event-details-meta" id="detailLocation" data-label="Local" hidden></div>
        <div class="event-details-meta" id="detailDescription" data-label="Observações" hidden></div>
        <div class="event-details-acolytes" id="detailAcolytesSection" hidden>
          <div class="event-details-acolytes-title">Escala de acólitos</div>
          <ul class="acolyte-list" id="detailAcolytes"></ul>
        </div>
        <div class="details-actions">
          <button id="editEvent" class="btn mini" type="button">Editar</button>
          <button id="deleteEvent" class="btn danger mini" type="button">Excluir</button>
        </div>
      </div>
    </aside>
  </main>

  <!-- Popover posicionado fora do grid para evitar problemas de layout -->
  <div id="dayOverlay" class="day-overlay" role="dialog" aria-modal="false" aria-live="polite" hidden>
    <div class="day-overlay-head">
      <div class="day-overlay-date" id="dayOverlayDate">Eventos</div>
      <button type="button" id="dayOverlayClose" class="day-overlay-close" aria-label="Fechar lista de eventos">&times;</button>
    </div>
    <div class="day-overlay-list" id="dayOverlayList"></div>
  </div>

  <!-- Modal de opções -->
  <div id="optionsModal" class="modal" hidden>
    <div class="modal-content panel">
      <div class="modal-header">
        <h2>Opções</h2>
        <button id="closeModal" class="btn ghost mini" type="button" aria-label="Fechar modal">&times;</button>
      </div>
      <div class="modal-body">
        <div class="modal-brand">
          <div class="liturgical-frame">
            <span class="alpha-omega-symbol">Α</span>
            <div class="main-title">ACOLI</div>
            <span class="alpha-omega-symbol">Ω</span>
          </div>
          <div class="subtitle">
            Administração de Conjuntos de Ofícios Litúrgicos Inteligente
          </div>
        </div>

        <div class="options-grid">
          <div class="card">
            <h3>API Groq</h3>
            <div class="field" title="Sua chave NUNCA deve ir para produção no front-end">
              <label for="apiKey">Chave API:</label>
              <input id="apiKey" type="password" placeholder="gsk_..." autocomplete="off" />
              <button id="reveal" class="btn ghost mini" type="button" aria-pressed="false" aria-controls="apiKey">ver</button>
            </div>
            <div class="field">
              <label for="model">Modelo:</label>
              <select id="model" aria-label="Modelo">
                <option value="openai/gpt-oss-20b" selected>GPT-OSS 20B (rápido)</option>
                <option value="openai/gpt-oss-120b">GPT-OSS 120B (mais capaz)</option>
              </select>
            </div>
            <div class="field">
              <label for="reasoningFormat">Formato de raciocínio:</label>
              <select id="reasoningFormat">
                <option value="">(padrão)</option>
                <option value="parsed">parsed (separa raciocínio)</option>
                <option value="hidden">hidden (sem raciocínio)</option>
              </select>
            </div>
            <div class="field">
              <label for="reasoningEffort">Esforço de raciocínio (GPT-OSS):</label>
              <select id="reasoningEffort">
                <option value="">(padrão)</option>
                <option value="low">low</option>
                <option value="medium" selected>medium</option>
                <option value="high">high</option>
              </select>
            </div>
            <div class="field">
              <label><input type="checkbox" id="jsonMode"/> Saída JSON estrita (ações)</label>
            </div>
            <div class="modal-actions">
              <button id="testBtn" class="btn mini" type="button">Testar API</button>
            </div>
          </div>

          <div class="card">
            <h3>Preferências</h3>
            <label title="Estação litúrgica">
              <select id="season">
                <option value="green">Tempo Comum (Verde)</option>
                <option value="violet">Advento / Quaresma (Roxo)</option>
                <option value="white">Natal / Páscoa (Branco & Dourado)</option>
                <option value="red">Pentecostes / Mártires (Vermelho)</option>
                <option value="rose">Gaudete / Laetare (Rosa)</option>
                <option value="black">Exéquias (Preto)</option>
              </select>
            </label>
            <div class="hint">Muda cores do tema litúrgico.</div>
            <div class="field">
              <label><input type="checkbox" id="preferDayViewMore"/> Preferir vista de dia ao clicar "+N mais"</label>
            </div>
            <div class="hint">Abre a vista diária em vez do popover.</div>
            <button id="contrast" class="btn ghost mini" type="button">Alto contraste</button>
            <div class="hint">Melhora acessibilidade visual.</div>
            <div class="modal-actions">
              <button id="clearChat" class="btn danger mini" type="button">Limpar chat</button>
            </div>
          </div>
        </div>

        <div class="manual">
          <strong>Como usar:</strong> Digite mensagens como "Dom 19:30 — Missa na Matriz. LIB: João; CRU: Ana".<br>
          O Acoli cria/edita/muda missas automaticamente. Use <code>listar próximos 14 dias</code> para ver a agenda.
        </div>
      </div>
    </div>
  </div>

  <!-- Modal de edição de evento -->
  <div id="eventModal" class="modal" hidden>
    <div class="modal-content panel">
      <div class="modal-header">
        <h2 id="eventModalTitle">Criar Missa</h2>
        <button id="closeEventModal" class="btn ghost mini" type="button" aria-label="Fechar modal">&times;</button>
      </div>
      <div class="modal-body">
        <div class="field">
          <label for="eventTitle">Título:</label>
          <input id="eventTitle" type="text" placeholder="Nome da missa" />
        </div>
        <div class="field">
          <label for="eventStart">Início:</label>
          <input id="eventStart" type="datetime-local" />
        </div>
        <div class="field">
          <label for="eventEnd">Fim:</label>
          <input id="eventEnd" type="datetime-local" />
        </div>
        <div class="field">
          <label for="eventDuration">Duração (min):</label>
          <input id="eventDuration" type="number" min="1" placeholder="60" />
        </div>
        <div class="field">
          <label for="eventLocation">Local:</label>
          <input id="eventLocation" type="text" placeholder="Igreja..." />
        </div>
        <div class="field">
          <label for="eventDescription">Observações:</label>
          <textarea id="eventDescription" rows="3" placeholder="Detalhes adicionais"></textarea>
        </div>
        <div class="field">
          <label for="eventAcolytes">Acólitos:</label>
          <textarea id="eventAcolytes" rows="2" placeholder="LIB: João, CAM: Maria"></textarea>
        </div>
        <div class="field">
          <label for="eventRrule">Recorrência (RRULE):</label>
          <input id="eventRrule" type="text" placeholder="FREQ=WEEKLY;BYDAY=SU" />
        </div>
        <div class="modal-actions">
          <button id="saveEvent" class="btn primary" type="button">Salvar</button>
          <button id="cancelEvent" class="btn ghost" type="button">Cancelar</button>
        </div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <script>
    // ======= Prevenir erros de recursos bloqueados =======
    window.addEventListener('error', function(e) {
      if (e.target && e.target.src && e.target.src.includes('googlesyndication')) {
        e.preventDefault(); return false;
      }
    }, true);

    // ======= Estado & Persistência =======
    const TZ = Intl.DateTimeFormat().resolvedOptions().timeZone || 'America/Sao_Paulo';
    const AGENT_NAME = 'Acoli';
    const SYSTEM_PROMPT = `
Você é o ${AGENT_NAME}, um assistente de IA especializado em agendamento litúrgico (pt-BR).

REGRAS DE SAÍDA (OBRIGATÓRIO - SEMPRE SIGA):
1. Primeira linha: UMA frase curta confirmando a ação
2. Segunda linha: Sempre inclua um bloco de código JSON
3. NUNCA omita o JSON - toda resposta deve ter texto + JSON

FORMATO OBRIGATÓRIO:
[Texto de confirmação]
\`\`\`json
{"schedule":{"action":"...", ...}}
\`\`\`

EXEMPLOS:
- Delete: "Missas apagadas." + JSON com action delete
- Create: "Missa criada." + JSON com action create

AÇÕES SUPORTADAS:
1) Forma canônica (um evento):
   {"schedule":{
     "action":"create|update|delete|move|list",
     "id":"(opcional)",
     "title":"Título da missa",
     "start":"YYYY-MM-DDTHH:MM",
     "end":"(opcional) YYYY-MM-DDTHH:MM",
     "durationMinutes": 60,
     "duration":"(opcional) PT60M",
     "startTime":"(opcional) HH:MM:SS (para RRULE)",
     "rrule":"(opcional) ex. FREQ=WEEKLY;BYDAY=SA;DTSTART=2025-10-04T17:00:00",
     "location":"Local",
     "description":"Obs",
     "acolytes": {"LIB":"Nome", "CRU":"Nome", "CAM":"Nome"}
   }}

2) Atalho multi-dia (DIAS CONSECUTIVOS, NÃO usar para finais de semana):
   {"action":"create_mass_schedule",
    "start_date":"YYYY-MM-DD",
    "days":N,                  // N dias consecutivos
    "time":"HH:MM",
    "location":"Local",
    "event":"Título",
    "acolytes":{...}}

⚠️ Recorrente semanal (sábados, domingos etc.): **NUNCA** use create_mass_schedule.
Use SEMPRE:
{"schedule":{
  "action":"create",
  "title":"...",
  "rrule":"FREQ=WEEKLY;BYDAY=SA;DTSTART=YYYY-MM-DDTHH:MM:00",
  "duration":"PT60M",
  "location":"...",
  "acolytes":{...}
}}

⚠️ Para RRULE: **NUNCA** use UNTIL=YYYY-MM-DDTHH:mm:ss (ISO). Use sempre UNTIL=YYYYMMDDTHHmmss (compacto).

3) Ações para ocorrências específicas (excluir/editar uma ocorrência de série recorrente):
   {"action":"delete_occurrence", "id":"id-do-evento-recorrente", "occurrence_date":"YYYY-MM-DDTHH:MM"}
   {"action":"update_occurrence", "id":"id-do-evento-recorrente", "occurrence_date":"YYYY-MM-DDTHH:MM", "new_start":"YYYY-MM-DDTHH:MM", "title":"...", "location":"...", "acolytes":{...}}
   {"action":"move_occurrence", "id":"id-do-evento-recorrente", "occurrence_date":"YYYY-MM-DDTHH:MM", "new_start":"YYYY-MM-DDTHH:MM"}

Impressão no chat:
- Para listar: {"schedule":{"action":"list","days":14}} // padrão próximos 14 dias
  (ou use "windowStart":"YYYY-MM-DD","windowEnd":"YYYY-MM-DD")

Apagar TUDO: {"schedule":{"action":"delete","id":"ALL"}}
Apagar por título: {"schedule":{"action":"delete","title":"Missa"}}
Mover:
- Relativo: {"schedule":{"action":"move","id":"...","deltaMinutes":30}}
- Absoluto: {"schedule":{"action":"move","id":"...","to":"YYYY-MM-DDTHH:MM"}}

Códigos de acólitos: LIB, CAM, CRU, CER, TUR, NAV, MIC.
Sinônimos aceitos: librífero, campanário, cruciferário, ceroferário, turiferário, naveteiro, microfonário.
Se não especificar nomes, posso atribuir aleatoriamente do roster disponível.

Seja sucinto, objetivo e liturgicamente coerente.
`;

    const messagesEl = document.getElementById('messages');
    const inputEl = document.getElementById('input');
    const sendBtn = document.getElementById('send');
    const apiKeyEl = document.getElementById('apiKey');
    const revealBtn = document.getElementById('reveal');
    const modelEl = document.getElementById('model');
    const reasoningFormatEl = document.getElementById('reasoningFormat');
    const reasoningEffortEl = document.getElementById('reasoningEffort');
    const jsonModeEl = document.getElementById('jsonMode');
    const preferDayViewMoreEl = document.getElementById('preferDayViewMore');
    const testBtn = document.getElementById('testBtn');
    const clearChatBtn = document.getElementById('clearChat');
    const toast = document.getElementById('toast');
    const eventDetailsEl = document.getElementById('eventDetails');
    const eventDetailsEmptyEl = eventDetailsEl?.querySelector('.event-details-empty') || null;
    const eventDetailsContentEl = eventDetailsEl?.querySelector('.event-details-content') || null;
    const detailTitleEl = document.getElementById('detailTitle');
    const detailTimeEl = document.getElementById('detailTime');
    const detailLocationEl = document.getElementById('detailLocation');
    const detailDescriptionEl = document.getElementById('detailDescription');
    const detailAcolytesSectionEl = document.getElementById('detailAcolytesSection');
    const detailAcolytesEl = document.getElementById('detailAcolytes');
    const editEventBtn = document.getElementById('editEvent');
    const deleteEventBtn = document.getElementById('deleteEvent');
    const dayOverlayEl = document.getElementById('dayOverlay');
    const dayOverlayDateEl = document.getElementById('dayOverlayDate');
    const dayOverlayListEl = document.getElementById('dayOverlayList');
    const dayOverlayCloseBtn = document.getElementById('dayOverlayClose');

    const eventModal = document.getElementById('eventModal');
    const eventModalTitle = document.getElementById('eventModalTitle');
    const closeEventModalBtn = document.getElementById('closeEventModal');
    const eventTitleEl = document.getElementById('eventTitle');
    const eventStartEl = document.getElementById('eventStart');
    const eventEndEl = document.getElementById('eventEnd');
    const eventDurationEl = document.getElementById('eventDuration');
    const eventLocationEl = document.getElementById('eventLocation');
    const eventDescriptionEl = document.getElementById('eventDescription');
    const eventAcolytesEl = document.getElementById('eventAcolytes');
    const eventRruleEl = document.getElementById('eventRrule');
    const saveEventBtn = document.getElementById('saveEvent');
    const cancelEventBtn = document.getElementById('cancelEvent');

    const SETTINGS = {
      get apiKey(){ return localStorage.getItem('groq_api_key') || ''; },
      set apiKey(v){ localStorage.setItem('groq_api_key', v || ''); },
      get model(){ return localStorage.getItem('groq_model') || 'openai/gpt-oss-20b'; },
      set model(v){ localStorage.setItem('groq_model', v || 'openai/gpt-oss-20b'); },
      get jsonMode(){ return localStorage.getItem('groq_json_mode') === '1'; },
      set jsonMode(on){ localStorage.setItem('groq_json_mode', on ? '1':'0'); },
      get reasoningFormat(){ return localStorage.getItem('groq_reasoning_format') || ''; },
      set reasoningFormat(v){ localStorage.setItem('groq_reasoning_format', v || ''); },
      get reasoningEffort(){ return localStorage.getItem('groq_reasoning_effort') || 'medium'; },
      set reasoningEffort(v){ localStorage.setItem('groq_reasoning_effort', v || 'medium'); },
      get preferDayViewMore(){ return localStorage.getItem('prefer_day_view_more') === '1'; },
      set preferDayViewMore(on){ localStorage.setItem('prefer_day_view_more', on ? '1':'0'); },
    };

    const STORE = {
      get events(){ try { return JSON.parse(localStorage.getItem('events_v2')||'[]'); } catch { return []; } },
      set events(v){ localStorage.setItem('events_v2', JSON.stringify(v)); }
    };

    const ACOLYTE_ROLES = {
      LIB: { label: 'Librífero', short: 'LIB', aliases: ['LIBRIFERO'] },
      CAM: { label: 'Campanário', short: 'CAM', aliases: ['CAMPANARIO'] },
      CRU: { label: 'Cruciferário', short: 'CRU', aliases: ['CRUCIFERARIO', 'CRUZIFERARIO'] },
      CER: { label: 'Ceroferário', short: 'CER', aliases: ['CEROFERARIO', 'CERIFERARIO'] },
      TUR: { label: 'Turiferário', short: 'TUR', aliases: ['TURIFERARIO'] },
      NAV: { label: 'Naveteiro', short: 'NAV', aliases: ['NAVETEIRO'] },
      MIC: { label: 'Microfonário', short: 'MIC', aliases: ['MICROFONARIO', 'MICROFONISTA'] },
    };
    const ROLE_ORDER = ['LIB','CAM','CRU','CER','TUR','NAV','MIC'];

    // Sinônimos para papéis (para reconhecimento flexível)
    const ROLE_SYNONYMS = {
      'librífero': 'LIB', 'lib': 'LIB', 'livro': 'LIB',
      'campanário': 'CAM', 'cam': 'CAM', 'campana': 'CAM', 'campanista': 'CAM',
      'cruciferário': 'CRU', 'cru': 'CRU', 'cruz': 'CRU', 'crucifixo': 'CRU',
      'ceroferário': 'CER', 'cer': 'CER', 'vela': 'CER', 'cero': 'CER',
      'turiferário': 'TUR', 'tur': 'TUR', 'incenso': 'TUR', 'turíbulo': 'TUR',
      'naveteiro': 'NAV', 'nav': 'NAV', 'naveta': 'NAV',
      'microfonário': 'MIC', 'mic': 'MIC', 'microfone': 'MIC', 'micro': 'MIC'
    };

    // Lista de acólitos disponíveis (exemplo; pode ser editada)
    const ROSTER = [
      'João Silva', 'Maria Santos', 'Pedro Oliveira', 'Ana Costa', 'Lucas Pereira',
      'Sofia Almeida', 'Mateus Ferreira', 'Isabela Rodrigues', 'Gabriel Carvalho', 'Laura Martins'
    ];

    // Função para preencher acólitos aleatoriamente
    function fillRandomAcolytes(roles = ['LIB', 'CAM', 'CRU']) {
      const assigned = {};
      const available = [...ROSTER];
      roles.forEach(role => {
        if (available.length === 0) return;
        const randomIndex = Math.floor(Math.random() * available.length);
        assigned[role] = available.splice(randomIndex, 1)[0];
      });
      return assigned;
    }

    function stripAccents(str){
      return (str || '').normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }

    function normalizeRole(role){
      if (!role) return '';
      const raw = String(role).trim();
      if (!raw) return '';
      const cleaned = stripAccents(raw).toUpperCase().replace(/[^A-Z]/g, '');
      if (ACOLYTE_ROLES[cleaned]) return cleaned;
      // Verificar sinônimos
      const synonym = ROLE_SYNONYMS[stripAccents(raw).toLowerCase()];
      if (synonym && ACOLYTE_ROLES[synonym]) return synonym;
      for (const [key, meta] of Object.entries(ACOLYTE_ROLES)){
        const aliases = meta.aliases || [];
        const labelNormalized = stripAccents(meta.label).toUpperCase().replace(/[^A-Z]/g, '');
        if (cleaned === labelNormalized || aliases.includes(cleaned)) return key;
      }
      if (cleaned.length === 3) return cleaned;
      return cleaned || raw.toUpperCase();
    }

    function normalizeAcolytes(raw){
      if (!raw) return [];
      const acc = [];
      const push = (role, name) => {
        const cleanName = typeof name === 'string' ? name.trim() : '';
        if (!role || !cleanName) return;
        acc.push({ role: normalizeRole(role), name: cleanName });
      };

      const parseString = (str) => {
        str.split(/[\n;,]/).forEach(part => {
          const piece = part.trim();
          if (!piece) return;
          const [rolePart, ...rest] = piece.split(':');
          if (rest.length){
            push(rolePart, rest.join(':').trim());
            return;
          }
          const hyphenSplit = piece.split(/[-–—]/);
          if (hyphenSplit.length > 1){
            const role = hyphenSplit.shift();
            push(role, hyphenSplit.join('-').trim());
            return;
          }
          const match = piece.match(/^(\w{3})\s+(.+)$/);
          if (match) push(match[1], match[2].trim());
        });
      };

      if (Array.isArray(raw)){
        raw.forEach(item => {
          if (!item) return;
          if (typeof item === 'string'){
            parseString(item);
            return;
          }
          if (typeof item === 'object'){
            const role = item.role || item.code || item.key || item.type || item.funcao || item.func || item.position || item.label;
            const name = item.name || item.person || item.member || item.acolyte || item.assignee || item.value;
            if (role && name){ push(role, name); return; }
            if (role && Array.isArray(item.names)){ item.names.forEach(n => push(role, n)); }
          }
        });
      } else if (typeof raw === 'object'){
        Object.entries(raw).forEach(([role, value]) => {
          if (typeof value === 'string'){ push(role, value); return; }
          if (value && typeof value.name === 'string'){ push(role, value.name); }
        });
      } else if (typeof raw === 'string'){
        parseString(raw);
      }

      const seen = new Set();
      const unique = [];
      acc.forEach(item => {
        const role = item.role || '';
        const name = item.name || '';
        if (!role || !name) return;
        const key = role + '::' + name.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        unique.push({ role, name });
      });

      unique.sort((a,b) => {
        const ai = ROLE_ORDER.indexOf(a.role);
        const bi = ROLE_ORDER.indexOf(b.role);
        if (ai === -1 && bi === -1) return a.role.localeCompare(b.role);
        if (ai === -1) return 1;
        if (bi === -1) return -1;
        return ai - bi;
      });

      return unique;
    }

    function formatAcolytePrompt(acolytes){
      if (!acolytes || !acolytes.length) return '';
      return acolytes.map(({ role, name }) => {
        const meta = ACOLYTE_ROLES[role] || {};
        const short = meta.short || role;
        return `${short}: ${name}`;
      }).join(', ');
    }

    function summarizeAcolytes(acolytes){
      if (!acolytes || !acolytes.length) return '';
      const parts = acolytes.slice(0, 2).map(item => {
        const meta = ACOLYTE_ROLES[item.role] || {};
        return `${meta.short || item.role}: ${item.name}`;
      });
      if (acolytes.length > 2){
        parts.push(`+${acolytes.length - 2}`);
      }
      return parts.join(', ');
    }

    function showToast(msg, kind='ok'){
      toast.textContent = msg;
      toast.classList.toggle('err', kind!=='ok');
      // se o modal está aberto, garanta z-index maior que o modal
      toast.style.zIndex = (optionsModal && optionsModal.classList.contains('open')) ? 2001 : 20;
      toast.style.display = 'block';
      setTimeout(()=> toast.style.display='none', 3600);
    }

    // ======= FullCalendar =======
    let calendar;
    let calendarEl = null;
    let selectedEvent = null;
    let selectedEventId = null;
    let overlayTargetDayFrame = null;
    let overlayCleanupAutoUpdate = null;
    document.addEventListener('DOMContentLoaded', () => {
      // persistência de opções
      apiKeyEl.addEventListener('input', () => { SETTINGS.apiKey = apiKeyEl.value.trim(); });
      modelEl.addEventListener('change', () => {
        SETTINGS.model = modelEl.value;
        // Desabilitar Reasoning Format se modelo for GPT-OSS
        const isGptOss = /^openai\/gpt-oss-/i.test(modelEl.value);
        reasoningFormatEl.disabled = isGptOss;
        reasoningFormatEl.title = isGptOss ? 'Não aplicável aos modelos GPT-OSS (use Mostrar raciocínio)' : '';
      });
      reasoningFormatEl.addEventListener('change', () => { SETTINGS.reasoningFormat = reasoningFormatEl.value; });
      reasoningEffortEl.addEventListener('change', () => { SETTINGS.reasoningEffort = reasoningEffortEl.value || 'medium'; });
      jsonModeEl.addEventListener('change', () => { SETTINGS.jsonMode = !!jsonModeEl.checked; });
      preferDayViewMoreEl.addEventListener('change', () => { SETTINGS.preferDayViewMore = !!preferDayViewMoreEl.checked; });

      bootThemeControls();
      // Restaurar preferências
      apiKeyEl.value = SETTINGS.apiKey;
      modelEl.value = SETTINGS.model;
      reasoningFormatEl.value = SETTINGS.reasoningFormat;
      reasoningEffortEl.value = SETTINGS.reasoningEffort;
      jsonModeEl.checked = SETTINGS.jsonMode;
      preferDayViewMoreEl.checked = SETTINGS.preferDayViewMore;

      // Auto-resize do textarea
      const autosize = () => {
        inputEl.style.height = '0px';
        inputEl.style.height = Math.min(120, Math.max(54, inputEl.scrollHeight)) + 'px';
      };
      inputEl.addEventListener('input', autosize); autosize();

      calendarEl = document.getElementById('calendar');
      const storedEvents = STORE.events.map(prepareStoredEvent);
      calendar = new FullCalendar.Calendar(calendarEl, {
        locale: 'pt-br',
        timeZone: 'local',
        initialView: 'dayGridMonth',
        headerToolbar: {
          left: 'prev,next today',
          center: 'title',
          right: 'dayGridMonth,timeGridWeek,timeGridDay,listWeek'
        },
        selectable: true,
        selectMirror: true,
        nowIndicator: true,
        height: '100%',
        dayMaxEvents: true,
        dayMaxEventRows: 3,
        moreLinkContent: (args) => `+${args.num} mais`,
        events: storedEvents,
        eventContent: renderEventContent,
        eventDidMount: handleEventDidMount,
        select: (selInfo) => {
          closeDayOverlay();
          openEventCreator(selInfo);
          calendar.unselect();
        },
        eventClick: (info) => {
          if (info.jsEvent) info.jsEvent.preventDefault();
          closeDayOverlay();
          selectedEvent = info.event;
          selectedEventId = info.event.id;
          showEventDetails(info.event);
          updateEventSelection();
        },
        datesSet: () => closeDayOverlay()
      });
      calendar.render();
      
      hijackMoreLinkClicks();
      
      calendarEl.addEventListener('scroll', closeDayOverlay, { passive: true });
      
      clearEventDetails();

      if (editEventBtn){
        editEventBtn.addEventListener('click', () => {
          if (!selectedEvent){
            showToast('Selecione uma missa para editar.', 'err');
            return;
          }
          closeDayOverlay();
          openEventEditor(selectedEvent);
        });
      }
      if (deleteEventBtn){
        deleteEventBtn.addEventListener('click', () => {
          if (!selectedEvent){
            showToast('Selecione uma missa para excluir.', 'err');
            return;
          }
          if (!confirm('Remover esta missa do calendário?')) return;
          closeDayOverlay();
          selectedEvent.remove();
          saveEvents();
          clearEventDetails();
          showToast('Missa removida.');
        });
      }

      // Mensagem inicial
      pushBot(`Bem-vindo ao **${AGENT_NAME}**. Escreva como você falaria:
• "Dom 19:30 — Missa na Matriz. LIB: João; CRU: Ana"
Eu crio/edito/movo e organizo a escala litúrgica (LIB, CAM, CRU, CER, TUR, NAV, MIC).`);

      if (dayOverlayCloseBtn){
        dayOverlayCloseBtn.addEventListener('click', closeDayOverlay);
      }
      document.addEventListener('click', handleDocumentClick);
      document.addEventListener('keydown', handleDocumentKeydown);

      // Listeners para modal de evento
      if (closeEventModalBtn){
        closeEventModalBtn.addEventListener('click', closeEventModal);
      }
      if (saveEventBtn){
        saveEventBtn.addEventListener('click', saveEventFromModal);
      }
      if (cancelEventBtn){
        cancelEventBtn.addEventListener('click', closeEventModal);
      }
      eventModal.addEventListener('click', (e) => {
        if (e.target === eventModal) closeEventModal();
      });
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && eventModal.classList.contains('open')) closeEventModal();
      });

      // Adicionar listeners para botões do chat e modal
      sendBtn.addEventListener('click', onSend);
      inputEl.addEventListener('keydown', (e)=>{
        if(e.key==='Enter' && !e.shiftKey){ e.preventDefault(); onSend(); }
      });
      revealBtn.addEventListener('click', ()=>{
        const isPwd = apiKeyEl.type === 'password';
        apiKeyEl.type = isPwd ? 'text' : 'password';
        revealBtn.setAttribute('aria-pressed', String(isPwd));
      });
      clearChatBtn.addEventListener('click', ()=>{
        messagesEl.innerHTML = '';
        session = SESS.create(); history = session.history;
        showToast('Chat limpo.');
      });
      testBtn.addEventListener('click', async ()=>{
        testBtn.disabled = true; const old = testBtn.textContent; testBtn.textContent = 'Testando…';
        try { await testGroqKey(); showToast('Chave OK.'); }
        catch(err){ showToast('Falha: '+err.message, 'err'); }
        finally { testBtn.disabled = false; testBtn.textContent = old; }
      });
    });

    function isSameDay(a, b){
      if (!a || !b) return false;
      return a.getFullYear()===b.getFullYear() &&
             a.getMonth()===b.getMonth() &&
             a.getDate()===b.getDate();
    }

    function dayEvents(date){
      return calendar.getEvents()
        .filter(e => e.start && isSameDay(e.start, date))
        .sort((a, b) => (a.start?.getTime()||0) - (b.start?.getTime()||0));
    }



    function addEvent(evt){
      const payload = { ...(evt || {}) };
      if (!payload.end && payload.start) {
        const baseStart = payload.start instanceof Date ? new Date(payload.start) : new Date(payload.start);
        const mins = Number(payload.durationMinutes || 60) || 60;
        const end = new Date(baseStart.getTime());
        end.setMinutes(end.getMinutes() + mins);
        payload.end = end;
      }
      const prepared = prepareEventInput(payload);
      try {
        const created = calendar.addEvent(prepared);
        saveEvents();
        return created;
      } catch (err) {
        console.error('Erro ao adicionar evento:', err);
        showToast('Erro ao adicionar evento.', 'err');
        return null;
      }
    }


    function prepareStoredEvent(evt){
      const toIso = d => d ? new Date(d).toISOString() : null;
      return prepareEventInput(evt || {});
    }

    function prepareEventInput(evt){
      const base = { ...(evt || {}) };
      if (!base.id) base.id = generateEventId();
      if (typeof base.start === 'string') base.start = new Date(base.start);
      if (typeof base.end === 'string' && base.end) base.end = new Date(base.end);
      const extended = { ...(base.extendedProps || {}) };
      if (base.location && extended.location === undefined) extended.location = base.location;
      if (base.description && extended.description === undefined) extended.description = base.description;
      if (base.rrule && extended.rrule === undefined) extended.rrule = base.rrule;
      if (base.duration && extended.duration === undefined) extended.duration = base.duration;
      if (base.startTime && extended.startTime === undefined) extended.startTime = base.startTime;
      if (base.exdate && extended.exdate === undefined) extended.exdate = base.exdate;
      extended.acolytes = normalizeAcolytes(extended.acolytes || base.acolytes);
      base.extendedProps = extended;
      return base;
    }

    function generateEventId(){
      if (typeof crypto !== 'undefined' && crypto.randomUUID) return crypto.randomUUID();
      return 'evt_' + Math.random().toString(36).slice(2, 10);
    }

    function renderEventContent(arg){
      const card = document.createElement('div');
      card.className = 'event-card';

      const title = document.createElement('div');
      title.className = 'event-title';
      title.textContent = arg.event.title || 'Missa';
      card.appendChild(title);

      const timeText = formatEventTimeShort(arg.event);
      const location = arg.event.extendedProps?.location || '';
      const acolytes = normalizeAcolytes(arg.event.extendedProps?.acolytes);
      const infoParts = [];
      if (timeText) infoParts.push(timeText);
      if (location) infoParts.push(location);
      const acolyteSummary = summarizeAcolytes(acolytes);
      if (acolyteSummary) infoParts.push(acolyteSummary);
      if (infoParts.length){
        const metaEl = document.createElement('div');
        metaEl.className = 'event-meta';
        metaEl.textContent = infoParts.join(' • ');
        card.appendChild(metaEl);
      }

      card.style.borderLeft = '4px solid var(--accent)';

      return { domNodes: [card] };
    }

    function handleEventDidMount(arg){
      if (!arg || !arg.el) return;
      if (arg.event && arg.event.id) arg.el.dataset.eventId = arg.event.id;
      const tooltipParts = [];
      if (arg.event.title) tooltipParts.push(arg.event.title);
      const timeText = formatEventTimeShort(arg.event);
      if (timeText) tooltipParts.push(timeText);
      if (arg.event.extendedProps?.location) tooltipParts.push(arg.event.extendedProps.location);
      const acolyteSummary = summarizeAcolytes(normalizeAcolytes(arg.event.extendedProps?.acolytes));
      if (acolyteSummary) tooltipParts.push(`Acólitos: ${acolyteSummary}`);
      if (tooltipParts.length) arg.el.setAttribute('title', tooltipParts.join(' • '));
      arg.el.classList.toggle('is-selected', !!selectedEventId && arg.event.id === selectedEventId);
    }

    function updateEventSelection(){
      if (!calendarEl) return;
      calendarEl.querySelectorAll('.fc-event').forEach(node => {
        node.classList.toggle('is-selected', !!selectedEventId && node.dataset.eventId === selectedEventId);
      });
    }

    function formatEventTimeShort(event){
      if (!event || !event.start) return '';
      if (event.allDay) return 'Dia inteiro';
      const fmt = new Intl.DateTimeFormat('pt-BR', { hour: '2-digit', minute: '2-digit', timeZone: TZ });
      const start = event.start;
      const end = event.end;
      if (!end || start.getTime() === end.getTime()) return fmt.format(start);
      if (start.toDateString() === end.toDateString()) return `${fmt.format(start)} – ${fmt.format(end)}`;
      return `${fmt.format(start)} → ${fmt.format(end)}`;
    }

    function formatWeekdayDayMonth(date){
      if (!date) return '';
      const weekday = new Intl.DateTimeFormat('pt-BR', { weekday: 'long', timeZone: TZ }).format(date);
      const day = new Intl.DateTimeFormat('pt-BR', { day: '2-digit', timeZone: TZ }).format(date);
      const month = new Intl.DateTimeFormat('pt-BR', { month: 'long', timeZone: TZ }).format(date);
      return `${weekday}, ${day} de ${month}`;
    }

    function formatEventDateRange(event){
      if (!event || !event.start) return '';
      const timeFmt = new Intl.DateTimeFormat('pt-BR', { hour: '2-digit', minute: '2-digit', timeZone: TZ });
      const start = event.start;
      const end = event.end;
      const startLabel = formatWeekdayDayMonth(start);
      if (event.allDay) return `${startLabel} • dia inteiro`;
      if (!end || start.getTime() === end.getTime()) return `${startLabel} • ${timeFmt.format(start)}`;
      if (start.toDateString() === end.toDateString()){
        return `${startLabel} • ${timeFmt.format(start)} – ${timeFmt.format(end)}`;
      }
      const endLabel = formatWeekdayDayMonth(end);
      return `${startLabel} ${timeFmt.format(start)} → ${endLabel} ${timeFmt.format(end)}`;
    }

    function formatCountPt(count, singular, plural){
      if (count === 1) return `1 ${singular}`;
      return `${count} ${plural || singular + 's'}`;
    }

    function formatActionsCount(count){
      if (!count) return '';
      return formatCountPt(count, 'ação', 'ações');
    }

    function formatDateTimeInput(date){
      if (!date) return '';
      const d = new Date(date);
      const year = d.getFullYear();
      const month = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      const hours = String(d.getHours()).padStart(2, '0');
      const minutes = String(d.getMinutes()).padStart(2, '0');
      return `${year}-${month}-${day}T${hours}:${minutes}`;
    }

    function parseDateTimeInput(str){
      if (!str) return null;
      return new Date(str);
    }

    function closeDayOverlay(){
      if (!dayOverlayEl || dayOverlayEl.hidden) return;
      dayOverlayEl.hidden = true;
      dayOverlayEl.style.visibility = 'hidden';
      dayOverlayEl.setAttribute('aria-hidden', 'true');
      if (overlayTargetDayFrame){
        overlayTargetDayFrame.classList.remove('day-overlay-target');
        overlayTargetDayFrame = null;
      }
      if (overlayCleanupAutoUpdate) {
        overlayCleanupAutoUpdate();
        overlayCleanupAutoUpdate = null;
      }
    }

    function handleDocumentClick(e){
      if (!dayOverlayEl || dayOverlayEl.hidden) return;
      if (dayOverlayEl.contains(e.target)) return;
      if (e.target.closest && e.target.closest('.fc-daygrid-more-link')) return;
      // Permite clicar nas células do calendário sem fechar o popover
      if (e.target.closest && e.target.closest('#calendar')) {
        // Se clicou em uma célula do calendário, verifica se é para abrir outro popover
        const moreLinkClicked = e.target.closest('.fc-daygrid-more-link');
        if (!moreLinkClicked) {
          closeDayOverlay();
        }
      } else {
        closeDayOverlay();
      }
    }

    function handleDocumentKeydown(e){
      if (e.key === 'Escape') closeDayOverlay();
    }

    function hijackMoreLinkClicks(){
      const root = calendarEl;

      const openFromLink = (ev, link) => {
        if (SETTINGS.preferDayViewMore) {
          const dayEl = link.closest('.fc-daygrid-day');
          const dateStr = dayEl?.getAttribute('data-date');
          if (dateStr) {
            calendar.changeView('timeGridDay', dateStr);
            return;
          }
        }
        // fallback mobile: abre a view de dia
        if (window.innerWidth < 640) {
          const dayEl = link.closest('.fc-daygrid-day');
          const dateStr = dayEl?.getAttribute('data-date');
          if (dateStr) {
            calendar.changeView('timeGridDay', dateStr);
            return;
          }
        }
        const dayEl = link.closest('.fc-daygrid-day');
        const dateStr = dayEl?.getAttribute('data-date');
        const date = dateStr ? new Date(dateStr + 'T00:00:00') : null;
        const segs = calendar.getEvents()
          .filter(e => e.start && date && e.start.toDateString() === date.toDateString())
          .map(event => ({ event }));

        openDayOverlay({ date, segs, dayEl, jsEvent: ev });
      };

      const capture = (ev) => {
        const link = ev.target.closest?.('.fc-daygrid-more-link');
        if (!link) return;
        ev.preventDefault();
        ev.stopPropagation();
        ev.stopImmediatePropagation?.();
        openFromLink(ev, link);
      };

      // capture-phase cobre mousedown/touch/pointer e click
      root.addEventListener('pointerdown', capture, true);
      root.addEventListener('mousedown', capture, true);
      root.addEventListener('click', capture, true);
    }

    function positionDayOverlay(anchorEl) {
      const F = window.FloatingUIDOM;
      if (!F || typeof F.computePosition !== 'function') return;
      if (!(anchorEl instanceof Element) || !document.documentElement.contains(anchorEl)) return;
      if (!dayOverlayEl || !dayOverlayEl.isConnected) return;

      if (overlayCleanupAutoUpdate) overlayCleanupAutoUpdate();

      const padding = 12;
      overlayCleanupAutoUpdate = F.autoUpdate(anchorEl, dayOverlayEl, () => {
        const middleware = [
          F.offset(8),
          F.flip({ boundary: calendarEl, altBoundary: true, padding }),
          F.shift({ boundary: calendarEl, altBoundary: true, padding }),
        ];
        if (typeof F.size === 'function') {
          middleware.push(F.size({
            boundary: calendarEl,
            padding,
            apply({ availableWidth, availableHeight, elements }) {
              const head = elements.floating.querySelector('.day-overlay-head');
              const headH = head ? head.getBoundingClientRect().height : 0;
              const maxW = Math.max(240, Math.min(300, Math.floor(availableWidth)));
              elements.floating.style.minWidth = '240px';
              elements.floating.style.maxWidth = maxW + 'px';
              elements.floating.style.width    = Math.min(300, maxW) + 'px';
              const list = elements.floating.querySelector('#dayOverlayList');
              if (list) list.style.maxHeight = Math.max(120, Math.floor(availableHeight - headH - 16)) + 'px';
            }
          }));
        }

        F.computePosition(anchorEl, dayOverlayEl, {
          placement: 'right-start',
          strategy: 'fixed',
          middleware
        }).then(({x, y, placement}) => {
          dayOverlayEl.style.left = Math.round(x) + 'px';
          dayOverlayEl.style.top  = Math.round(y) + 'px';
          dayOverlayEl.style.visibility = 'visible';
          dayOverlayEl.setAttribute('data-placement', placement);
        });
      });
    }

    function openDayOverlay(info){
      if (!dayOverlayEl || !calendarEl) return;
      const events = (info.segs && info.segs.length
        ? info.segs.map(s => s.event)
        : (info.segs || [])
      ).filter(Boolean).reduce((acc, ev) => {
        if (!acc.some(e => e.id === ev.id)) acc.push(ev);
        return acc;
      }, []).sort((a,b) => (a.start?.getTime()||0) - (b.start?.getTime()||0));
      if (!events.length){
        closeDayOverlay();
        return;
      }

      const baseDate = info.date || events[0].start || new Date();
      if (dayOverlayDateEl){
        dayOverlayDateEl.textContent = formatWeekdayDayMonth(baseDate);
      }
      dayOverlayEl.setAttribute('aria-label', `Missas de ${formatWeekdayDayMonth(baseDate)}`);

      if (dayOverlayListEl){
        dayOverlayListEl.innerHTML = '';
        events.forEach(event => {
          const item = document.createElement('button');
          item.type = 'button';
          item.className = 'day-overlay-item';

          const title = document.createElement('div');
          title.className = 'item-title';
          title.textContent = event.title || 'Missa';
          item.appendChild(title);

          const timeRow = document.createElement('div');
          timeRow.className = 'item-meta';
          timeRow.textContent = formatEventTimeShort(event) || 'Horário não definido';
          item.appendChild(timeRow);

          const metaParts = [];
          const location = event.extendedProps?.location;
          if (location) metaParts.push(location);
          const acolyteSummary = summarizeAcolytes(normalizeAcolytes(event.extendedProps?.acolytes));
          if (acolyteSummary) metaParts.push(acolyteSummary);
          if (metaParts.length){
            const foot = document.createElement('div');
            foot.className = 'item-foot';
            foot.textContent = metaParts.join(' • ');
            item.appendChild(foot);
          }

          item.addEventListener('click', () => {
            selectedEvent = event;
            selectedEventId = event.id;
            showEventDetails(event);
            updateEventSelection();
            calendar.gotoDate(event.start);
            closeDayOverlay();
          });

          dayOverlayListEl.appendChild(item);
        });
      }

      // Preparação visual mínima (sem calcular posição manualmente)
      dayOverlayEl.hidden = false;
      dayOverlayEl.setAttribute('aria-hidden', 'false');
      dayOverlayEl.style.visibility = 'hidden';
      dayOverlayEl.style.position = 'fixed';
      dayOverlayEl.style.transform = 'translate(0,0)';

      // Anchor: o link "+N mais" se existir; senão, a célula
      const anchor =
        (info.jsEvent && info.jsEvent.target && info.jsEvent.target.closest('.fc-daygrid-more-link')) ||
        (info.dayEl && (info.dayEl.querySelector('.fc-daygrid-more-link') || info.dayEl)) ||
        info.dayEl || calendarEl;

      // Delega o posicionamento ao Floating UI
      positionDayOverlay(anchor);

      // Destaque da célula alvo (mantém seu comportamento atual)
      if (overlayTargetDayFrame){
        overlayTargetDayFrame.classList.remove('day-overlay-target');
      }
      overlayTargetDayFrame = info.dayEl?.querySelector('.fc-daygrid-day-frame') || info.dayEl;
      overlayTargetDayFrame?.classList.add('day-overlay-target');

      // Foco no botão fechar (acessibilidade)
      dayOverlayCloseBtn?.focus();
    }

    window.addEventListener('beforeunload', () => {
      if (overlayCleanupAutoUpdate) overlayCleanupAutoUpdate();
    });

    function populateAcolyteDetails(acolytes){
      if (!detailAcolytesEl) return;
      detailAcolytesEl.innerHTML = '';
      if (!acolytes.length){
        const li = document.createElement('li');
        li.className = 'acolyte-item empty';
        li.textContent = 'Nenhum acólito escalado.';
        detailAcolytesEl.appendChild(li);
        return;
      }
      acolytes.forEach(item => {
        const li = document.createElement('li');
        li.className = 'acolyte-item';
        const meta = ACOLYTE_ROLES[item.role] || {};
        const roleLabel = meta.label ? `${meta.label} (${meta.short || item.role})` : item.role;
        const roleEl = document.createElement('span');
        roleEl.className = 'acolyte-role';
        roleEl.textContent = roleLabel;
        const nameEl = document.createElement('span');
        nameEl.className = 'acolyte-name';
        nameEl.textContent = item.name;
        li.append(roleEl, nameEl);
        detailAcolytesEl.appendChild(li);
      });
    }

    function showEventDetails(event){
      if (!eventDetailsEl) return;
      if (!event){
        clearEventDetails();
        return;
      }
      const acolytes = normalizeAcolytes(event.extendedProps?.acolytes);
      if (eventDetailsEmptyEl) eventDetailsEmptyEl.hidden = true;
      if (eventDetailsContentEl) eventDetailsContentEl.hidden = false;
      if (detailTitleEl) detailTitleEl.textContent = event.title || 'Missa';
      if (detailTimeEl) detailTimeEl.textContent = formatEventDateRange(event);

      const location = event.extendedProps?.location || '';
      if (detailLocationEl){
        detailLocationEl.textContent = location;
        detailLocationEl.hidden = !location;
      }

      const description = event.extendedProps?.description || '';
      if (detailDescriptionEl){
        detailDescriptionEl.textContent = description;
        detailDescriptionEl.hidden = !description;
      }

      if (detailAcolytesSectionEl){
        detailAcolytesSectionEl.hidden = false;
      }
      populateAcolyteDetails(acolytes);
      updateEventSelection();
    }

    function clearEventDetails(){
      closeDayOverlay();
      if (eventDetailsEmptyEl) eventDetailsEmptyEl.hidden = false;
      if (eventDetailsContentEl) eventDetailsContentEl.hidden = true;
      if (detailTitleEl) detailTitleEl.textContent = 'Missa';
      if (detailTimeEl) detailTimeEl.textContent = '';
      if (detailLocationEl){
        detailLocationEl.textContent = '';
        detailLocationEl.hidden = true;
      }
      if (detailDescriptionEl){
        detailDescriptionEl.textContent = '';
        detailDescriptionEl.hidden = true;
      }
      if (detailAcolytesSectionEl){
        detailAcolytesSectionEl.hidden = true;
      }
      if (detailAcolytesEl) detailAcolytesEl.innerHTML = '';
      selectedEvent = null;
      selectedEventId = null;
      updateEventSelection();
    }

    function openEventModal(event = null, selInfo = null){
      if (!eventModal) return;
      const isEdit = !!event;
      eventModalTitle.textContent = isEdit ? 'Editar Missa' : 'Criar Missa';
      if (isEdit){
        eventTitleEl.value = event.title || '';
        eventStartEl.value = event.start ? formatDateTimeInput(event.start) : '';
        eventEndEl.value = event.end ? formatDateTimeInput(event.end) : '';
        eventDurationEl.value = '';
        eventLocationEl.value = event.extendedProps?.location || '';
        eventDescriptionEl.value = event.extendedProps?.description || '';
        eventAcolytesEl.value = formatAcolytePrompt(normalizeAcolytes(event.extendedProps?.acolytes));
        eventRruleEl.value = event.extendedProps?.rrule || '';
      } else if (selInfo){
        eventTitleEl.value = '';
        eventStartEl.value = selInfo.start ? formatDateTimeInput(selInfo.start) : '';
        eventEndEl.value = selInfo.end ? formatDateTimeInput(selInfo.end) : '';
        eventDurationEl.value = '60';
        eventLocationEl.value = '';
        eventDescriptionEl.value = '';
        eventAcolytesEl.value = '';
        eventRruleEl.value = '';
      } else {
        eventTitleEl.value = '';
        eventStartEl.value = '';
        eventEndEl.value = '';
        eventDurationEl.value = '60';
        eventLocationEl.value = '';
        eventDescriptionEl.value = '';
        eventAcolytesEl.value = '';
        eventRruleEl.value = '';
      }
      eventModal.hidden = false;
      eventModal.classList.add('open');
      eventModal.setAttribute('aria-hidden', 'false');
      document.body.style.overflow = 'hidden';
      eventTitleEl.focus();
      eventModal.dataset.mode = isEdit ? 'edit' : 'create';
      eventModal.dataset.eventId = isEdit ? event.id : '';
      eventModal.dataset.selInfo = JSON.stringify(selInfo || {});
    }

    function closeEventModal(){
      if (!eventModal) return;
      eventModal.classList.remove('open');
      eventModal.setAttribute('aria-hidden', 'true');
      eventModal.hidden = true;
      document.body.style.overflow = '';
    }

    function saveEventFromModal(){
      const mode = eventModal.dataset.mode;
      const eventId = eventModal.dataset.eventId;
      const selInfoStr = eventModal.dataset.selInfo;
      const selInfo = selInfoStr ? JSON.parse(selInfoStr) : null;

      const title = eventTitleEl.value.trim();
      if (!title){
        showToast('Informe o título da missa.', 'err');
        return;
      }
      const startStr = eventStartEl.value;
      const endStr = eventEndEl.value;
      const durationStr = eventDurationEl.value;
      const location = eventLocationEl.value.trim();
      const description = eventDescriptionEl.value.trim();
      const acolytesStr = eventAcolytesEl.value.trim();
      const rrule = eventRruleEl.value.trim();

      let start = startStr ? parseDateTimeInput(startStr) : null;
      let end = endStr ? parseDateTimeInput(endStr) : null;
      const duration = durationStr ? parseInt(durationStr, 10) : 60;

      if (mode === 'create'){
        if (rrule){
          // Recorrente
          const evt = {
            title,
            rrule,
            duration: `PT${duration}M`,
            extendedProps: {
              location,
              description,
              acolytes: normalizeAcolytes(acolytesStr),
              rrule,
              duration: `PT${duration}M`
            }
          };
          if (startStr){ // usa o horário do campo "Início"
            const d = parseDateTimeInput(startStr);
            const hh = String(d.getHours()).padStart(2,'0');
            const mm = String(d.getMinutes()).padStart(2,'0');
            evt.startTime = `${hh}:${mm}:00`;
            evt.extendedProps.startTime = evt.startTime;
          }
          try {
            const created = calendar.addEvent(prepareEventInput(evt));
            saveEvents();
            showToast('Missa recorrente criada.');
          } catch (err) {
            console.error('Erro ao criar missa recorrente:', err);
            showToast('Erro ao criar missa recorrente.', 'err');
          }
          closeEventModal();
        } else {
          // Simples
          if (!start){
            showToast('Informe a data/hora de início.', 'err');
            return;
          }
          if (!end){
            end = new Date(start.getTime() + duration * 60000);
          }
          const created = addEvent({
            title,
            start,
            end,
            extendedProps: {
              location,
              description,
              acolytes: normalizeAcolytes(acolytesStr)
            }
          });
          if (created){
            selectedEvent = created;
            selectedEventId = created.id;
            showEventDetails(created);
          }
          showToast('Missa criada.');
          closeEventModal();
        }
      } else if (mode === 'edit'){
        const event = calendar.getEventById(eventId);
        if (!event){
          showToast('Evento não encontrado.', 'err');
          return;
        }
        event.setProp('title', title);
        if (start) event.setStart(start);
        if (end) event.setEnd(end);
        event.setExtendedProp('location', location);
        event.setExtendedProp('description', description);
        event.setExtendedProp('acolytes', normalizeAcolytes(acolytesStr));
        if (rrule) event.setExtendedProp('rrule', rrule);
        saveEvents();
        showEventDetails(event);
        showToast('Missa atualizada.');
        closeEventModal();
      }
    }

    function openEventCreator(selInfo){
      openEventModal(null, selInfo);
    }

    function openEventEditor(event){
      if (!event) return;
      openEventModal(event);
    }

    function saveEvents(){
      const toIso = d => d ? new Date(d).toISOString() : null;
      const arr = calendar.getEvents().map(e => {
        const base = {
          id: e.id,
          title: e.title,
          allDay: e.allDay,
          extendedProps: {
            ...e.extendedProps,
            acolytes: normalizeAcolytes(e.extendedProps?.acolytes)
          }
        };
        if (e.extendedProps?.rrule){
          base.rrule = e.extendedProps.rrule;
          base.duration = e.extendedProps.duration;
          if (e.extendedProps.startTime) base.startTime = e.extendedProps.startTime;
          if (e.extendedProps.exdate) base.exdate = e.extendedProps.exdate; // <— NOVO
        } else {
          base.start = toIso(e.start);
          base.end = toIso(e.end);
        }
        return base;
      });
      STORE.events = arr;
    }

    // ======= Tema litúrgico =======
    function setSeason(key){
      const map = {
        green:  'var(--season-green)',
        violet: 'var(--season-violet)',
        white:  'var(--season-white)',
        red:    'var(--season-red)',
        rose:   'var(--season-rose)',
        black:  'var(--season-black)'
      };
      document.documentElement.style.setProperty('--accent', map[key] || 'var(--season-green)');
      localStorage.setItem('missal.season', key);
      // ligeiro ajuste de "pergaminho" para o modo preto
      const parchment = key === 'black' ? '#fbfbfb' : '#fffdf7';
      document.documentElement.style.setProperty('--parchment', parchment);
    }

    function bootThemeControls(){
      const seasonSel = document.getElementById('season');
      const contrastBtn = document.getElementById('contrast');

      if (seasonSel){
        const saved = localStorage.getItem('missal.season') || 'green';
        seasonSel.value = saved; setSeason(saved);
        seasonSel.addEventListener('change', e => setSeason(e.target.value));
      }
      if (contrastBtn){
        const high = localStorage.getItem('missal.contrast') === '1';
        if (high) document.body.classList.add('alto-contraste');
        contrastBtn.textContent = high ? 'Contraste normal' : 'Alto contraste';
        contrastBtn.addEventListener('click', () => {
          document.body.classList.toggle('alto-contraste');
          const on = document.body.classList.contains('alto-contraste');
          contrastBtn.textContent = on ? 'Contraste normal' : 'Alto contraste';
          localStorage.setItem('missal.contrast', on ? '1' : '0');
        });
      }
    }

    // ======= Sessões de chat =======
    const SESS = {
      get all(){ return JSON.parse(localStorage.getItem('sessions_v1')||'[]'); },
      set all(v){ localStorage.setItem('sessions_v1', JSON.stringify(v)); },
      create(){ const id = crypto.randomUUID(); const now = Date.now();
        const s = { id, title: 'Nova conversa', createdAt: now, updatedAt: now, history: [ { role:'system', content: SYSTEM_PROMPT } ] };
        const all = this.all; all.unshift(s); this.all = all; return s;
      },
      save(sess){ const all = this.all; const i = all.findIndex(x => x.id===sess.id);
        if (i>=0) all[i]=sess; else all.unshift(sess); this.all = all;
      },
      get(id){ return this.all.find(x => x.id===id); }
    };

    function approxTokens(str){ return Math.ceil((str||'').length / 4); }
    function pruneHistory(base, maxTokens = 6000){
      const out = [];
      let total = 0;
      for (let i=base.length-1;i>=0;i--){
        const chunk = JSON.stringify(base[i]);
        const t = approxTokens(chunk);
        if (total + t > maxTokens) break;
        out.unshift(base[i]); total += t;
      }
      // mantenha sempre o system no topo
      if (out[0]?.role !== 'system') out.unshift(base.find(m => m.role==='system') || { role:'system', content:SYSTEM_PROMPT });
      return out;
    }

    // ======= Chat UI =======
    let session = SESS.all[0] || SESS.create();
    let history = session.history;
    function pushUser(text){
      const wrap = document.createElement('div');
      wrap.className = 'bubble user';
      // Primeira mensagem do usuário ganha capitular (opcional): add "dropcap"
      const markup = missalMarkup(text);
      const firstParaCap = markup.replace('<p class="proclamation">','<p class="proclamation dropcap">');
      wrap.innerHTML = `<div class="meta">Você • ${new Date().toLocaleString('pt-BR')}</div>${firstParaCap}`;
      messagesEl.appendChild(wrap);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function makeDetails({raw, actions, sources}) {
      const details = document.createElement('details');
      const summary = document.createElement('summary');
      const count = (actions?.schedules?.length || 0) + (actions?.availability?.length || 0);
      const countLabel = formatActionsCount(count);
      summary.textContent = `detalhes${countLabel ? ` • ${countLabel}` : ''}`;
      details.appendChild(summary);

      if (actions?.availability?.length){
        const av = actions.availability[0];
        const slots = computeAvailability(av);
        const h = document.createElement('div');
        h.className = 'slot-list';
        slots.slice(0, av.count || 3).forEach(s => {
          const pill = document.createElement('div');
          pill.className = 'slot';
          pill.textContent = new Date(s.start).toLocaleString('pt-BR') + ` (${Math.round((s.end - s.start)/60000)} min)`;
          h.appendChild(pill);
        });
        details.appendChild(h);
      }

      if (actions?.schedules?.length){
        const pre = document.createElement('pre');
        pre.innerHTML = `<code>${escapeHtml(JSON.stringify(actions.schedules, null, 2))}</code>`;
        details.appendChild(pre);
      }

      if (raw){
        const preRaw = document.createElement('pre');
        preRaw.innerHTML = `<code>${escapeHtml(raw)}</code>`;
        details.appendChild(preRaw);
      }

      if (sources?.length){
        const src = document.createElement('div');
        src.className = 'sources';
        src.innerHTML = `<strong>Fontes:</strong> ` + sources.map(s => `<a target="_blank" href="${s.url}">${escapeHtml(s.title||s.url)}</a>`).join(' • ');
        details.appendChild(src);
      }

      if (actions?.schedules?.length){
        const btn = document.createElement('button');
        btn.className = 'btn mini ghost';
        btn.textContent = 'Copiar JSON de ações';
        btn.onclick = () => {
          navigator.clipboard.writeText(JSON.stringify(actions.schedules, null, 2));
          showToast('JSON copiado.');
        };
        details.appendChild(btn);
      }

      return details;
    }

    function pushBot(visibleText, opts={}){
      const wrap = document.createElement('div');
      wrap.className = 'bubble bot';
      const body = missalMarkup(visibleText || '');
      wrap.innerHTML = `<div class="meta">${AGENT_NAME} • ${new Date().toLocaleString('pt-BR')}</div>${body}`;
      if (opts.details) wrap.appendChild(makeDetails(opts.details));
      messagesEl.appendChild(wrap);
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function createBotStreamBubble(){
      const wrap = document.createElement('div');
      wrap.className = 'bubble bot is-typing';
      wrap.innerHTML = (`
        <div class="meta">${AGENT_NAME} • ${new Date().toLocaleString('pt-BR')}</div>
        <div class="typing-line">
          <span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span>
        </div>
      `).trim();
      messagesEl.appendChild(wrap);
      messagesEl.scrollTop = messagesEl.scrollHeight;

      const updateVisible = (text) => {
        const body = missalMarkup(text || '');
        wrap.classList.remove('is-typing');
        const details = wrap.querySelector('details');
        wrap.innerHTML = `<div class="meta">${AGENT_NAME} • ${new Date().toLocaleString('pt-BR')}</div>${body}`;
        if (details) wrap.appendChild(details); // preserva se já existir
        messagesEl.scrollTop = messagesEl.scrollHeight;
      };

      const attachDetails = ({raw, actions, sources}) => {
        const d = makeDetails({ raw, actions, sources });
        wrap.appendChild(d);
      };

      const injectActionProgress = () => {
        let bar = wrap.querySelector('.action-progress');
        if (!bar){
          bar = document.createElement('div');
          bar.className = 'action-progress';
          bar.innerHTML = `
            <div class="action-progress-head">Executando ações…</div>
            <div class="action-progress-bar"><div class="fill"></div></div>
          `;
          wrap.appendChild(bar);
        }
        return {
          tick: (p) => { bar.querySelector('.fill').style.width = `${Math.max(0,Math.min(100,p))}%`; },
          done: () => { bar.classList.add('done'); }
        };
      };

      return { el: wrap, updateVisible, attachDetails, injectActionProgress };
    }

    // ======= Chamada Groq =======

    async function testGroqKey() {
      const key = (apiKeyEl.value || '').trim();
      if (!key) throw new Error('Chave ausente');
      const model = modelEl.value || 'openai/gpt-oss-20b';

      const resp = await fetch('https://api.groq.com/openai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${key}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model,
          messages: [{ role: 'user', content: 'ping' }],
          max_tokens: 1
        })
      });
      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(`Erro API (${resp.status}): ${txt}`);
      }
    }

    // ======= Chamada Groq =======
    let inflight;
    async function streamCallGroq({ onDelta, onFence, onDone }) {
      if (inflight) inflight.abort();
      inflight = new AbortController();

      const key = (apiKeyEl.value || '').trim();
      if (!key){ showToast('Cole sua chave da Groq no topo.', 'err'); throw new Error('Chave ausente'); }
      const model = modelEl.value || 'openai/gpt-oss-20b';
      const reasoningFormat = SETTINGS.reasoningFormat;
      const reasoningEffort = SETTINGS.reasoningEffort;
      const jsonMode = SETTINGS.jsonMode;

      const body = {
        model,
        messages: pruneHistory(history),
        temperature: 0.2,
        stream: true
      };

      const isGptOss = /^openai\/gpt-oss-/i.test(model);
      // JSON mode: deixe desmarcado por padrão (senão você perde o texto + cercas)
      if (jsonMode) body.response_format = { type: 'json_object' };
      // Reasoning Effort: suportado por GPT-OSS (low|medium|high)
      if (reasoningEffort) body.reasoning_effort = reasoningEffort;
      // Reasoning format: NÃO envie para GPT-OSS
      if (!isGptOss && reasoningFormat) {
        body.reasoning_format = reasoningFormat; // p.ex. qwen-qwq-32b
      }
      // Para GPT-OSS, use include_reasoning conforme a UI
      if (isGptOss) {
        // mapeie "(padrão|parsed)" => include_reasoning:true; "hidden" => false
        if (reasoningFormat === 'hidden') body.include_reasoning = false;
        else if (reasoningFormat === 'parsed' || reasoningFormat === '') body.include_reasoning = true;
      }

      const resp = await fetch('https://api.groq.com/openai/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${key}`,
          'Content-Type': 'application/json',
          'Accept': 'text/event-stream'  // <- ajuda alguns proxies/navegadores
        },
        body: JSON.stringify(body),
        signal: inflight.signal
      });
      if (!resp.ok){
        const txt = await resp.text();
        throw new Error(`Erro API (${resp.status}): ${txt}`);
      }

      const reader   = resp.body.getReader();
      const decoder  = new TextDecoder('utf-8');
      let sseBuffer  = '';
      let fullVisible = '';
      let rawAll     = '';
      let sourcesCollected = []; // Groq não retorna sources, mas mantemos para compatibilidade

      // buffers para cercas ```
      let inFence = false, fenceLang = '', fenceBuffer = '';
      
      // Para evitar processar o mesmo JSON inline múltiplas vezes
      const processedInlineJsons = new Set();

      const flushVisible = () => onDelta?.(redactActionMentions(fullVisible));

      while (true) {
        const { value, done } = await reader.read();
        if (done) break;

        sseBuffer += decoder.decode(value, { stream: true });

        // divide por linha em branco, suportando CRLF/LF
        const events = sseBuffer.split(/\r?\n\r?\n/);
        sseBuffer = events.pop() || '';

        for (const ev of events) {
          // junta todas as linhas "data:" (SSE permite várias)
          const dataLines = ev.split(/\r?\n/)
            .filter(line => line.startsWith('data:'))
            .map(line => line.slice(5).trimStart());

          if (!dataLines.length) continue;

          const data = dataLines.join('\n');
          if (data === '[DONE]') { try { reader.cancel(); } catch {} break; }

          let payload;
          try { payload = JSON.parse(data); } catch { continue; }

          const delta = payload?.choices?.[0]?.delta?.content || '';
          if (delta) {
            rawAll += delta;

            // detecta/fecha cercas ``` para capturar JSON de ações
            for (let i = 0; i < delta.length; i++) {
              if (delta.slice(i, i+3) === '```') {
                if (!inFence) {
                  inFence = true; fenceLang = '';
                  const m = delta.slice(i+3).match(/^(\w+)?/);
                  fenceLang = m && m[1] ? m[1].toLowerCase() : '';
                } else {
                  const tryFenceAsJson =
                    !fenceLang || /^(json|jsonc)$/i.test(fenceLang);

                  if (tryFenceAsJson) {
                    const raw = fenceBuffer.trim();
                    const parsed = tryParseJson(raw);
                    if (parsed) {
                      onFence?.(parsed);
                    } else {
                      // fallback: tenta achar {"schedule":{...}} por varredura
                      extractInlineJsonByKey(raw, 'schedule').forEach(obj => onFence?.(obj));
                    }
                  }
                  inFence = false; fenceLang = ''; fenceBuffer = '';
                }
                i += 2; // pula os ```
                continue;
              }
              if (inFence) fenceBuffer += delta[i];
              else fullVisible += delta[i];
            }

            // NOVO: Detectar JSON inline enquanto o texto está sendo construído
            // Usa regex mais robusta que suporta objetos aninhados
            const inlineJsonMatches = fullVisible.match(/\{"schedule":\{(?:[^{}]|\{[^}]*\})*\}\}/g);
            if (inlineJsonMatches) {
              inlineJsonMatches.forEach(jsonStr => {
                if (!processedInlineJsons.has(jsonStr)) {
                  processedInlineJsons.add(jsonStr);
                  const parsed = tryParseJson(jsonStr);
                  if (parsed && parsed.schedule) {
                    console.log('🔥 Processing inline JSON during stream:', jsonStr);
                    onFence?.(parsed);
                  }
                }
              });
            }

            // ADICIONAL: Detectar qualquer JSON que tenha "action" na raiz
            const actionJsonMatches = fullVisible.match(/\{"action":"[^"]+",?[^}]*\}/g);
            if (actionJsonMatches) {
              actionJsonMatches.forEach(jsonStr => {
                if (!processedInlineJsons.has(jsonStr)) {
                  processedInlineJsons.add(jsonStr);
                  const parsed = tryParseJson(jsonStr);
                  if (parsed && parsed.action) {
                    console.log('🔥 Processing action JSON during stream:', jsonStr);
                    onFence?.(parsed);
                  }
                }
              });
            }

            flushVisible();
          }

          // Groq não retorna search_results, então sourcesCollected permanece vazio
        }
      }

      onDone?.({ raw: rawAll, sources: sourcesCollected });
    }

    // ======= Parser de respostas =======
    function extractJsonFences(text){
      const fences = [];
      const regex = /```(?:json|jsonc)?\s*([\s\S]*?)\s*```/gi;
      let m;
      while ((m = regex.exec(text)) !== null) {
        const raw = m[1].trim();
        fences.push(raw);
      }
      return fences;
    }
    function tryParseJson(str){
      try { return JSON.parse(str); } catch { return null; }
    }
    function extractInlineJsonByKey(text, key){
      const results = [];
      let idx = 0;
      while ((idx = text.indexOf(`"${key}"`, idx)) !== -1) {
        let start = text.lastIndexOf('{', idx);
        if (start === -1) { idx += key.length; continue; }
        let depth = 0, i = start;
        for (; i < text.length; i++) {
          const ch = text[i];
          if (ch === '{') depth++;
          else if (ch === '}') {
            depth--;
            if (depth === 0) { 
              const jsonStr = text.slice(start, i+1);
              const obj = tryParseJson(jsonStr);
              if (obj && obj[key]) results.push(obj);
              break;
            }
          }
        }
        if (i >= text.length) break;
        idx = i + 1;
      }
      return results;
    }
    function extractMessagesFrom(obj) {
      if (obj && typeof obj === 'object' && obj.message) {
        return String(obj.message).trim();
      }
      return null;
    }
    function extractTopLevelJson(raw) {
      const lines = String(raw || '').split(/\r?\n/);
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed.startsWith('{') && trimmed.endsWith('}')) {
          const parsed = tryParseJson(trimmed);
          if (parsed) return parsed;
        }
      }
      return null;
    }
    function splitVisibleFromActions(raw){
      const fences = extractJsonFences(raw);
      const parsedFromFences = fences.map(tryParseJson).filter(Boolean);

      let visible = raw.replace(/```(?:json|jsonc)?\s*([\s\S]*?)\s*```/gi, '').trim();

      const actions = { schedules: [], availability: [] };
      parsedFromFences.forEach(p => collectAction(p, actions));

      // NOVO: Detectar JSON inline (fora de cercas) - procura por chaves "schedule"
      const inlineJsonSchedules = extractInlineJsonByKey(visible, 'schedule');
      inlineJsonSchedules.forEach(obj => collectAction(obj, actions));

      // NOVO: Detectar JSON inline com "action" na raiz 
      const inlineJsonActions = extractInlineJsonByKey(visible, 'action');
      inlineJsonActions.forEach(obj => collectAction(obj, actions));

      // NOVO: Detectar JSON linha inteira (caso o AI retorne só JSON)
      const topLevelJson = extractTopLevelJson(visible);
      if (topLevelJson && (topLevelJson.schedule || topLevelJson.action)) {
        collectAction(topLevelJson, actions);
      }

      // Remove JSON inline do texto visível (versão mais robusta)
      visible = visible.replace(/\{"schedule":\{(?:[^{}]|\{[^}]*\})*\}\}/g, '').trim();
      visible = visible.replace(/\{"action":"[^"]+",?[^}]*\}/g, '').trim();
      visible = visible.replace(/^\{"[^"]*":\{.*\}\}$/gm, '').trim();

      // Fallback: se não há texto visível, tenta extrair "message" dos objetos JSON
      if (!visible) {
        for (const obj of parsedFromFences) {
          const msg = extractMessagesFrom(obj);
          if (msg) {
            visible = msg;
            break;
          }
        }
      }

      return { visibleText: visible, actions, raw };
    }
    function flattenActions(input){
      const acc = [];
      const walk = (x) => {
        if (!x) return;
        if (Array.isArray(x)) { x.forEach(walk); return; }
        if (x.schedules && Array.isArray(x.schedules)) { x.schedules.forEach(walk); return; }
        if (x.schedule || x.action) { acc.push(x); return; }
        // Se vier um objeto simples com campos de schedule na raiz (fallback)
        if (x.rrule || x.start || x.title || x.deltaMinutes) { acc.push({ schedule: x }); return; }
      };
      walk(input);
      return acc;
    }
    function collectAction(obj, actions){
      const items = flattenActions(obj);
      for (const it of items){
        const topAction = String(it.action || '').toLowerCase();
        const looksLikeAction =
          it.schedule && typeof it.schedule === 'object' ||
          /^create_?mass(_schedule)?$/.test(topAction) ||
          /^(update|delete|move|list)_?mass(es)?$/.test(topAction) ||
          /^(update|move|delete)_occurrence$/.test(topAction);
        if (looksLikeAction) {
          // Verifica se já existe uma ação idêntica para evitar duplicatas na coleta
          const actionKey = getActionKey(it);
          const alreadyExists = actions.schedules.some(existing => getActionKey(existing) === actionKey);
          if (!alreadyExists) {
            actions.schedules.push(it);
          }
        }
      }
    }

    // ======= Helpers para RRULE & impressão =======
function getWeekdayCodeFromDate(d){
  return ['SU','MO','TU','WE','TH','FR','SA'][d.getDay()];
}
function formatYmd(d){ return d.toISOString().slice(0,10); }
function atTime(d, hhmm='19:30'){
  const [hh,mm] = String(hhmm).split(':').map(n=>+n||0);
  const z = new Date(d); z.setHours(hh, mm, 0, 0); return z;
}
function fmtHhmm(d){
  return new Intl.DateTimeFormat('pt-BR', { hour:'2-digit', minute:'2-digit', timeZone: TZ }).format(d);
}
function fmtDdmmyy(d){
  return new Intl.DateTimeFormat('pt-BR', { day:'2-digit', month:'2-digit', year:'2-digit', timeZone: TZ }).format(d);
}
function fmtWeekdayDdmmy(d){
  const wd = new Intl.DateTimeFormat('pt-BR', { weekday:'short', timeZone: TZ }).format(d);
  return `${wd.replace('.','')}, ${new Intl.DateTimeFormat('pt-BR',{day:'2-digit',month:'2-digit',timeZone:TZ}).format(d)}`;
}
function parseDtstartFromRrule(rr){
  const m = String(rr||'').match(/DTSTART=([^;]+)/i);
  if (!m) return null;
  const s = m[1].trim();
  // aceita 'YYYY-MM-DDTHH:mm:ss' ou 'YYYYMMDDTHHmmss'
  if (/^\d{8}T\d{6}Z?$/.test(s)){
    const y = +s.slice(0,4), mo = +s.slice(4,6)-1, d = +s.slice(6,8), h = +s.slice(9,11), mi = +s.slice(11,13), se = +s.slice(13,15);
    return new Date(y,mo,d,h,mi,se);
  }
  return new Date(s);
}
function deriveStartTime(s, rruleMaybe){
  const pad2 = (n)=> String(n).padStart(2,'0');

  const hhmm = (t)=>{
    const m = String(t||'').match(/^(\d{1,2}):(\d{2})$/);
    return m ? `${pad2(+m[1])}:${pad2(+m[2])}:00` : null;
  };
  const hhmmss = (t)=>{
    const m = String(t||'').match(/^(\d{1,2}):(\d{2}):(\d{2})$/);
    return m ? `${pad2(+m[1])}:${pad2(+m[2])}:${pad2(+m[3])}` : null;
  };

  // 1) Campos explícitos
  if (s && typeof s === 'object'){
    if (s.startTime) return hhmmss(s.startTime) || hhmm(s.startTime) || '19:30:00';
    if (s.time)      return hhmm(s.time)       || hhmmss(s.time)   || '19:30:00';
    if (s.at)        return hhmm(s.at)         || hhmmss(s.at)     || '19:30:00';
    if (s.start){
      const d = new Date(s.start);
      if (!isNaN(+d)) return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:00`;
    }
  }

  // 2) DTSTART dentro da RRULE (string)
  const rr = typeof rruleMaybe === 'string' ? rruleMaybe : (s?.rrule || '');
  const dt = parseDtstartFromRrule(rr);
  if (dt) return `${pad2(dt.getHours())}:${pad2(dt.getMinutes())}:${pad2(dt.getSeconds())}`;

  // 3) Padrão
  return '19:30:00';
}
function rruleOptionsFromString(rr, fallbackDtStart=null){
  const opts = RRule.parseString(rr || '');
  if (!opts.dtstart){
    const ds = parseDtstartFromRrule(rr);
    opts.dtstart = ds || fallbackDtStart || new Date();
  }
  return opts;
}
function parseMinutes(isoOrNum){
  if (typeof isoOrNum === 'number') return isoOrNum;
  if (typeof isoOrNum !== 'string') return 60;
  const m = isoOrNum.match(/^PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$/i);
  if (!m) return 60;
  const h = +m[1]||0, mi = +m[2]||0, s = +m[3]||0;
  return h*60 + mi + Math.round(s/60);
}
function toCompactDateTime(d) {
  // YYYYMMDDTHHMMSS (sem Z para TZ local; FullCalendar usa tz do calendário)
  const y = d.getFullYear();
  const m = String(d.getMonth()+1).padStart(2,'0');
  const day = String(d.getDate()).padStart(2,'0');
  const hh = String(d.getHours()).padStart(2,'0');
  const mm = String(d.getMinutes()).padStart(2,'0');
  const ss = String(d.getSeconds()).padStart(2,'0');
  return `${y}${m}${day}T${hh}${mm}${ss}`;
}
function hhmmFromMinutes(mins=60){
  const h = Math.floor(mins/60);
  const m = mins%60;
  return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
}
// Aceita string ou objeto; garante dtstart, corrige UNTIL ISO -> compacto; injeta tzid quando possível.
function normalizeRRule(rruleInput, { defaultTime='18:30', tzid = TZ } = {}) {
  let opts;
  if (typeof rruleInput === 'string') {
    // Converte UNTIL=YYYY-MM-DDTHH:mm:ss -> UNTIL=YYYYMMDDTHHmmss
    let s = rruleInput.trim();

    s = s.replace(/UNTIL=\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}Z?/i, (m) => {
      const iso = m.split('=')[1];
      const d = new Date(iso);
      return `UNTIL=${toCompactDateTime(d)}`;
    });

    // Se não tem DTSTART, cria com "próxima ocorrência" no horário pedido (ou default)
    const hasDtstart = /DTSTART=/i.test(s);
    if (!hasDtstart) {
      // tentamos inferir BYDAY. Se não houver, assumimos o dia de hoje
      let by = (s.match(/BYDAY=([A-Z,]+)/i)?.[1] || '').split(',')[0] || getWeekdayCodeFromDate(new Date());
      const target = new Date();
      const weekdays = ['SU','MO','TU','WE','TH','FR','SA'];
      while (weekdays[target.getDay()] !== by) target.setDate(target.getDate()+1);

      const [hh,mm] = defaultTime.split(':').map(n=>+n||0);
      target.setHours(hh, mm, 0, 0);
      s = `${s}${s.endsWith(';')?'':';'}DTSTART=${formatYmd(target)}T${String(hh).padStart(2,'0')}:${String(mm).padStart(2,'0')}:00`;
    }

    // Converte para options para injetar tzid
    opts = RRule.parseString(s);
  } else {
    opts = { ...(rruleInput||{}) };
  }

  // Corrige UNTIL se vier string
  if (typeof opts.until === 'string') {
    const d = new Date(opts.until);
    if (!isNaN(+d)) opts.until = d;
  }

  // Garante dtstart
  if (!opts.dtstart) {
    const base = new Date();
    const [hh,mm] = (typeof defaultTime === 'string' ? defaultTime : '18:30').split(':').map(n=>+n||0);
    base.setHours(hh, mm, 0, 0);
    opts.dtstart = base;
  }

  // Seta tzid se disponível (rrule >=2.6)
  if (tzid) opts.tzid = tzid;

  // Regera string normalizada
  const normalized = new RRule(opts).toString(); // gera BYDAY/UNTIL/DTSTART nos formatos certos
  return { opts, rruleString: normalized };
}
// Expande um evento (simples ou recorrente) em ocorrências dentro da janela:
function expandOccurrences(ev, winStart, winEnd){
  const out = [];
  if (ev.extendedProps?.rrule){
    const rr = String(ev.extendedProps.rrule);
    const startTime = ev.extendedProps.startTime || '19:30:00';
    let dtstart = parseDtstartFromRrule(rr);
    if (!dtstart){
      // fallback: usa a data de início da janela no horário do evento
      const hhmm = startTime.slice(0,5);
      dtstart = atTime(winStart, hhmm);
    }
    const opts = rruleOptionsFromString(rr, dtstart);
    const rule = new RRule(opts);
    const between = rule.between(winStart, winEnd, true);
    const dur = parseMinutes(ev.extendedProps.duration || 60);
    between.forEach(s => {
      const start = new Date(s);
      const end = new Date(start.getTime() + dur*60000);
      out.push({ start, end, title: ev.title, location: ev.extendedProps?.location||'', acolytes: normalizeAcolytes(ev.extendedProps?.acolytes||[]) });
    });
  } else if (ev.start){
    const start = new Date(ev.start);
    const end = ev.end ? new Date(ev.end) : new Date(start.getTime() + 60*60000);
    if (start < winEnd && end > winStart){
      out.push({ start, end, title: ev.title, location: ev.extendedProps?.location||'', acolytes: normalizeAcolytes(ev.extendedProps?.acolytes||[]) });
    }
  }
  return out;
}
function smartPrintList({ windowStart=null, windowEnd=null, days=14 } = {}){
  const start = windowStart ? new Date(windowStart) : new Date();
  start.setHours(0,0,0,0);
  const end   = windowEnd ? new Date(windowEnd) : new Date(start.getTime() + (days*24*60*60000));
  const occs = [];
  calendar.getEvents().forEach(ev => occs.push(...expandOccurrences(ev, start, end)));
  occs.sort((a,b)=> a.start - b.start);

  if (!occs.length){
    pushBot(`Nenhuma missa entre ${fmtDdmmyy(start)} e ${fmtDdmmyy(end)}.\n\nQuer outro período? Diga: "liste de 01/10 a 31/10" ou "liste próximos 30 dias".`);
    return;
  }
  // agrupar por dia
  const byDay = new Map();
  occs.forEach(o => {
    const key = formatYmd(o.start);
    if (!byDay.has(key)) byDay.set(key, []);
    byDay.get(key).push(o);
  });

  const lines = [];
  lines.push(`Rubrica: Próximas missas (${fmtDdmmyy(start)} – ${fmtDdmmyy(end)})`);
  for (const [ymd, list] of [...byDay.entries()].sort()){
    const d = new Date(ymd + 'T00:00:00');
    lines.push(`${fmtWeekdayDdmmy(d)}`);
    list.forEach(o => {
      const tail = [
        fmtHhmm(o.start),
        o.title || 'Missa',
        o.location ? `· ${o.location}` : '',
        o.acolytes?.length ? `· ${summarizeAcolytes(o.acolytes)}` : ''
      ].filter(Boolean).join(' ');
      lines.push(`• ${tail}`);
    });
    lines.push(''); // linha em branco
  }
  lines.push('Deseja outro período? Posso listar "próximos 7 dias", "de 01/11 a 15/11", etc.');
  pushBot(lines.join('\n'));
}
function pushConfirmDeleteAll(total, onConfirm, onCancel){
  const wrap = document.createElement('div');
  wrap.className = 'bubble bot';
  
  // Meta info
  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.textContent = `${AGENT_NAME} • ${new Date().toLocaleString('pt-BR')}`;
  wrap.appendChild(meta);
  
  // Message content
  const message = document.createElement('div');
  message.className = 'proclamation';
  message.innerHTML = `⚠️ <strong>Confirma apagar TODAS as missas?</strong><br>Serão excluídas <strong>${total}</strong> ${total === 1 ? 'missa' : 'missas'} do calendário.`;
  wrap.appendChild(message);
  
  // Button row
  const row = document.createElement('div');
  row.style.cssText = 'display: flex; gap: 8px; margin-top: 12px; align-items: center;';
  
  const yes = document.createElement('button');
  yes.className = 'btn danger mini';
  yes.textContent = `🗑️ Excluir ${total === 1 ? '1 missa' : `${total} missas`}`;
  yes.type = 'button';
  
  const no = document.createElement('button');
  no.className = 'btn mini';
  no.textContent = '❌ Cancelar';
  no.type = 'button';
  
  row.append(yes, no);
  wrap.appendChild(row);
  
  // Add to messages and scroll
  messagesEl.appendChild(wrap);
  messagesEl.scrollTop = messagesEl.scrollHeight;

  // Event handlers
  yes.addEventListener('click', () => {
    onConfirm?.();
    wrap.remove();
  });
  
  no.addEventListener('click', () => {
    onCancel?.();
    wrap.remove();
    showToast('Exclusão cancelada.');
  });
}

    // ======= Execução das ações =======
    function isoOrDate(v){ return v ? new Date(v) : null; }

    function applyScheduleAction(schedObj){
      if (Array.isArray(schedObj)) { schedObj.forEach(applyScheduleAction); return; }
      // --- atalhos para ações top-level comuns ------------------------------------
      const topAction = String(schedObj.action || '').toLowerCase();

      // Coloque no escopo de applyScheduleAction (ou acima), uma única vez
      function parseDateLocal(dateStr){
        if (!dateStr) return null;
        const s = String(dateStr).trim();
        if (/^\d{4}-\d{2}-\d{2}$/.test(s)) { const [y,m,d]=s.split('-').map(Number); return new Date(y, m-1, d); }
        const m = s.match(/^(\d{1,2})[\/\-](\d{1,2})(?:[\/\-](\d{2,4}))?$/);
        if (m){ let yy = m[3] ? +m[3] : (new Date()).getFullYear(); if (yy<100) yy+=2000; return new Date(yy, +m[2]-1, +m[1]); }
        return new Date(s);
      }
      function parseHm(timeStr){
        const m = String(timeStr || '').match(/^(\d{1,2}):(\d{2})$/);
        return m ? { h:+m[1], m:+m[2] } : { h:19, m:30 };
      }

      if (topAction === 'create_mass' || topAction === 'create-mass') {
        const dateObj = parseDateLocal(schedObj.date || schedObj.when || schedObj.on);
        if (!dateObj || isNaN(+dateObj)){ showToast('Data inválida para criação de missa.', 'err'); return; }
        const { h, m } = parseHm(schedObj.time || schedObj.at);
        const start = new Date(dateObj); start.setHours(h, m, 0, 0);
        const mins = Number(schedObj.durationMinutes) || parseIsoDurationToMinutes(schedObj.duration) || 60;
        const end = new Date(start.getTime() + mins * 60000);

        const title = schedObj.title || schedObj.event || 'Missa';
        const location = schedObj.location || '';
        const acolytes = normalizeAcolytes(schedObj.acolytes);

        const created = addEvent({
          title, start, end,
          extendedProps: { location, acolytes }
        });

        if (created){
          selectedEvent = created; selectedEventId = created.id;
          showEventDetails(created);
        }
        saveEvents();
        showToast('Missa criada.');
        return;
      }

      if (schedObj.action === 'create_mass_schedule') {
        const title = schedObj.event || schedObj.title || 'Missa';
        const location = schedObj.location || '';
        const timeStr = schedObj.time || schedObj.at || '19:30';
        const startDateRaw = schedObj.start_date || schedObj.startDate || schedObj.date || schedObj.on || schedObj.when;
        const baseDate = parseDateLocal(startDateRaw);
        const acolytes = normalizeAcolytes(schedObj.acolytes);
        // Suporte a 'weeks' (novo) ou 'days' (legado):
        const weeks = Number(schedObj.weeks ?? 0);
        const days  = Number(schedObj.days ?? 0);

        if (!baseDate || isNaN(+baseDate)) { showToast('Data de início inválida para agendamento múltiplo.', 'err'); return; }

        // Heurística:
        // - se 'weeks' informado => RRULE semanal com COUNT=weeks
        // - senão, se 'days >= 8' => interpretamos como "semanas", e usamos RRULE semanal com COUNT=days
        // - caso contrário => manter comportamento antigo (dias consecutivos)
        const useWeekly = weeks > 0 || days >= 8 || String(schedObj.repeat||'').toLowerCase()==='weekly' || !!schedObj.weekly || String(schedObj.freq||'').toUpperCase()==='WEEKLY';

        if (useWeekly){
          const count = weeks > 0 ? weeks : Math.max(1, days);
          const byday = getWeekdayCodeFromDate(baseDate);
          const dtstart = atTime(baseDate, timeStr);
          const durationISO = 'PT60M'; // padrão; poderia ler de schedObj.durationMinutes
          const rrule = `FREQ=WEEKLY;BYDAY=${byday};COUNT=${count};DTSTART=${formatYmd(dtstart)}T${String(dtstart.getHours()).padStart(2,'0')}:${String(dtstart.getMinutes()).padStart(2,'0')}:00`;

          const evt = prepareEventInput({
            title,
            rrule,
            startTime: `${String(dtstart.getHours()).padStart(2,'0')}:${String(dtstart.getMinutes()).padStart(2,'0')}:00`,
            duration: durationISO,
            extendedProps: { location, acolytes, rrule, duration: durationISO, startTime: `${String(dtstart.getHours()).padStart(2,'0')}:${String(dtstart.getMinutes()).padStart(2,'0')}:00` }
          });
          try {
            calendar.addEvent(evt);
            saveEvents();
            showToast(`Missa recorrente criada (semanal, ${count} ocorrências).`);
          } catch (err) {
            console.error('Erro ao criar missa recorrente:', err);
            showToast('Erro ao criar missa recorrente.', 'err');
          }
          return;
        }

        // ——— fallback: criar dias consecutivos (comportamento antigo) ———
        const { h, m } = (function parseHm(timeStr){ const mm = String(timeStr||'').match(/^(\d{1,2}):(\d{2})$/); return mm ? { h:+mm[1], m:+mm[2] } : { h:19, m:30 }; })(timeStr);
        const consecutiveDays = Math.max(1, days || 1);
        let createdCount = 0;
        for (let day = 0; day < consecutiveDays; day++) {
          const eventDate = new Date(baseDate);
          eventDate.setDate(baseDate.getDate() + day);
          const start = new Date(eventDate); start.setHours(h, m, 0, 0);
          const end = new Date(start.getTime() + 60 * 60000);
          const created = addEvent({ title, start, end, extendedProps: { location, acolytes } });
          if (created) createdCount++;
        }
        saveEvents();
        showToast(createdCount === 1 ? '1 missa agendada.' : `${createdCount} missas agendadas.`);
        return;
      }

      const s = schedObj.schedule || {};
      const action = (s.action || 'create').toLowerCase();

      if (action === 'delete') {
        // 3.1) Apagar tudo (formas aceitas)
        const deleteAll = (s.id === 'ALL' || s.id === '*' || s.title === 'ALL' || s.title === '*'
                           // tolera o caso do LLM ter mandado só "delete"
                           || (!s.id && !s.title && !s.windowStart && !s.windowEnd));
        
        if (deleteAll){
          const total = calendar.getEvents().length;
          if (total === 0) {
            showToast('Não há missas para apagar.', 'info');
            return;
          }
          pushConfirmDeleteAll(total, () => {
            calendar.getEvents().forEach(e => e.remove());
            saveEvents(); clearEventDetails(); showToast('Todas as missas foram removidas.');
          }, () => { /* cancelado */ });
          return;
        }

        // 3.2) Apagar por janela de datas (opcional)
        if (s.windowStart || s.windowEnd){
          const start = isoOrDate(s.windowStart) || new Date(-8640000000000000);
          const end   = isoOrDate(s.windowEnd)   || new Date( 8640000000000000);
          let removed = 0;
          calendar.getEvents().forEach(e=>{
            const evStart = e.start;
            const evEnd   = e.end || new Date(evStart.getTime() + 60*60000);
            if (evStart < end && evEnd > start){ e.remove(); removed++; }
          });
          saveEvents(); clearEventDetails();
          showToast(removed ? `${removed} missas removidas.` : 'Nenhuma missa removida.');
          return;
        }

        // 3.3) Apagar por id
        if (s.id){
          const ev = calendar.getEventById(s.id);
          if (ev){
            const wasSelected = selectedEvent && selectedEvent.id === ev.id;
            ev.remove();
            saveEvents();
            if (wasSelected) clearEventDetails();
            showToast('Missa removida.');
          } else { showToast('Evento não encontrado para remoção.', 'err'); }
          return;
        }

        // 3.4) Apagar por título (parcial)
        if (s.title){
          let removed = 0;
          calendar.getEvents().forEach(e => {
            if ((e.title || '').toLowerCase().includes(String(s.title).toLowerCase())) {
              const wasSelected = selectedEvent && selectedEvent.id === e.id;
              e.remove();
              if (wasSelected) clearEventDetails();
              removed++;
            }
          });
          saveEvents();
          if (removed === 0){
            showToast('Nenhuma missa removida.');
          } else if (removed === 1){
            showToast('1 missa removida.');
          } else {
            showToast(`${removed} missas removidas.`);
          }
          return;
        }
      }

      if (action === 'move' && (s.id || s.title) && (s.to || s.newStart)){
        const targets = findEventsByIdOrTitle(s.id, s.title);
        if (!targets.length){ showToast('Nenhum evento encontrado para mover.', 'err'); return; }
        let newStart;
        if (s.to){
          newStart = parseDateLocal(s.to);
          if (!newStart || isNaN(+newStart)){ showToast('Data inválida para mover.', 'err'); return; }
          if (s.time){
            const { h, m } = parseHm(s.time);
            newStart.setHours(h, m, 0, 0);
          }
        } else if (s.newStart){
          newStart = isoOrDate(s.newStart);
          if (!newStart){ showToast('Data/hora inválida para mover.', 'err'); return; }
        }
        targets.forEach(ev => {
          const duration = ev.end ? ev.end.getTime() - ev.start.getTime() : 0;
          const newEnd = duration ? new Date(newStart.getTime() + duration) : null;
          ev.setDates(newStart, newEnd, { maintainDuration: !newEnd });
        });
        if (selectedEvent && targets.some(ev => ev.id === selectedEvent.id)){
          showEventDetails(selectedEvent);
        }
        saveEvents();
        const moveLabel = targets.length === 1 ? 'Missa movida' : `${targets.length} missas movidas`;
        showToast(`${moveLabel} para ${newStart.toLocaleString()}.`);
        return;
      }

      if (action === 'move' && (s.id || s.title) && s.deltaMinutes){
        const delta = Number(s.deltaMinutes) || 0;
        const targets = findEventsByIdOrTitle(s.id, s.title);
        if (!targets.length){ showToast('Nenhum evento encontrado para mover.', 'err'); return; }
        targets.forEach(ev => {
          const start = new Date(ev.start);
          const end = ev.end ? new Date(ev.end) : null;
          start.setMinutes(start.getMinutes() + delta);
          if (end) end.setMinutes(end.getMinutes() + delta);
          ev.setDates(start, end, { maintainDuration: !end });
        });
        if (selectedEvent && targets.some(ev => ev.id === selectedEvent.id)){
          showEventDetails(selectedEvent);
        }
        saveEvents();
        const absDelta = Math.abs(delta);
        const minuteLabel = absDelta === 1 ? 'minuto' : 'minutos';
        const direction = delta > 0 ? 'para frente' : (delta < 0 ? 'para trás' : '');
        const moveLabel = targets.length === 1 ? 'Missa movida' : `${targets.length} missas movidas`;
        const suffix = direction ? ` ${direction}` : '';
        showToast(`${moveLabel} em ${absDelta} ${minuteLabel}${suffix}.`);
        return;
      }

      if (action === 'update' && (s.id || s.title)){
        const targets = findEventsByIdOrTitle(s.id, s.title);
        if (!targets.length){ showToast('Nenhum evento encontrado para atualizar.', 'err'); return; }
        const start = isoOrDate(s.start);
        const end = isoOrDate(s.end);
        targets.forEach(ev => {
          if (s.title && !s.id) ev.setProp('title', s.title);
          if (start) ev.setStart(start);
          if (end || start) ev.setEnd(end || null);
          if (s.location !== undefined){
            ev.setExtendedProp('location', s.location || '');
          }
          if (s.description !== undefined){
            ev.setExtendedProp('description', s.description || '');
          }
          if (s.acolytes !== undefined){
            ev.setExtendedProp('acolytes', normalizeAcolytes(s.acolytes));
          }
        });
        if (selectedEvent && targets.some(ev => ev.id === selectedEvent.id)){
          showEventDetails(selectedEvent);
        }
        saveEvents();
        const msg = targets.length === 1 ? 'Evento atualizado.' : `${targets.length} eventos atualizados.`;
        showToast(msg);
        return;
      }

      if (action === 'list'){
        smartPrintList({
          windowStart: s.windowStart,
          windowEnd: s.windowEnd,
          days: s.days || 14
        });
        return;
      }

      if (action === 'create'){
        const title = s.massName || s.title || 'Missa';
        const location = s.location || '';
        const description = s.description || '';
        const acolytes = normalizeAcolytes(s.acolytes);
        
        console.log('DEBUG CREATE ACTION:', { title, location, description, acolytes, rrule: s.rrule });
        
        if (s.rrule){
          const mins = parseMinutes(s.duration || s.durationISO || s.durationMinutes || 60);

          // 👇 Derivamos a hora de início
          const startTimeStr = deriveStartTime(s, s.rrule); // "HH:MM:SS"
          console.log('DEBUG RRULE PROCESSING:', { rrule: s.rrule, mins, startTimeStr });

          const { rruleString } = normalizeRRule(s.rrule, {
            defaultTime: startTimeStr.slice(0,5), // "HH:MM"
            tzid: TZ
          });
          
          console.log('DEBUG NORMALIZED RRULE:', { rruleString });

          const evt = prepareEventInput({
            id: s.id || undefined,
            title,
            rrule: rruleString,
            duration: hhmmFromMinutes(mins), // para o FullCalendar
            startTime: startTimeStr,
            extendedProps: {
              description, location, acolytes,
              rrule: rruleString,
              duration: `PT${mins}M`,       // guardamos ISO para sua expansão manual
              startTime: startTimeStr
            }
          });
          
          console.log('DEBUG EVENT INPUT:', evt);

          try {
            calendar.addEvent(evt);
            console.log('DEBUG: Event added to calendar successfully');
            saveEvents();
          } catch (error) {
            console.error('DEBUG ERROR adding event:', error);
            showToast('Erro ao criar missa recorrente.', 'err');
          }
          showToast('Missa recorrente criada.');
          return;
        } else {
          const start = isoOrDate(s.start);
          let end = isoOrDate(s.end);
          if (!start){ showToast('Criação ignorada: "start" ausente.', 'err'); return; }
          if (!end){
            const d = new Date(start);
            const mins = Number(s.durationMinutes) || parseIsoDurationToMinutes(s.duration) || 60;
            d.setMinutes(d.getMinutes() + mins);
            end = d;
          }
          try {
            const created = addEvent({
              id: s.id || undefined,
              title,
              start, end,
              extendedProps: { description, location, acolytes }
            });
            if (created){
              selectedEvent = created;
              selectedEventId = created.id;
              showEventDetails(created);
            }
            showToast('Missa criada.');
          } catch (err) {
            console.error('Erro ao criar missa:', err);
            showToast('Erro ao criar missa.', 'err');
          }
          return;
        }
      }
      if (topAction === 'delete_occurrence') {
        const occDate = isoOrDate(schedObj.occurrence_date);
        if (!occDate) { showToast('Data da ocorrência inválida para exclusão.', 'err'); return; }
        const ev = calendar.getEventById(schedObj.id);
        if (!ev || !ev.extendedProps?.rrule) { showToast('Evento recorrente não encontrado.', 'err'); return; }
        const currentExdate = ev.extendedProps.exdate || '';
        const newExdate = currentExdate ? `${currentExdate},${toCompactDateTime(occDate)}` : toCompactDateTime(occDate);
        ev.setExtendedProp('exdate', newExdate);
        saveEvents();
        showToast('Ocorrência excluída.');
        return;
      }

      if (topAction === 'update_occurrence') {
        const occDate = isoOrDate(schedObj.occurrence_date);
        if (!occDate) { showToast('Data da ocorrência inválida para atualização.', 'err'); return; }
        const ev = calendar.getEventById(schedObj.id);
        if (!ev || !ev.extendedProps?.rrule) { showToast('Evento recorrente não encontrado.', 'err'); return; }
        // Adicionar ao exdate
        const currentExdate = ev.extendedProps.exdate || '';
        const newExdate = currentExdate ? `${currentExdate},${toCompactDateTime(occDate)}` : toCompactDateTime(occDate);
        ev.setExtendedProp('exdate', newExdate);
        // Criar nova ocorrência simples
        const newStart = isoOrDate(schedObj.new_start || schedObj.start);
        const newEnd = isoOrDate(schedObj.new_end || schedObj.end);
        if (!newStart) { showToast('Nova data/hora inválida.', 'err'); return; }
        const title = schedObj.title || ev.title;
        const location = schedObj.location !== undefined ? schedObj.location : ev.extendedProps.location;
        const description = schedObj.description !== undefined ? schedObj.description : ev.extendedProps.description;
        const acolytes = schedObj.acolytes !== undefined ? normalizeAcolytes(schedObj.acolytes) : ev.extendedProps.acolytes;
        const created = addEvent({
          title,
          start: newStart,
          end: newEnd,
          extendedProps: { location, description, acolytes }
        });
        saveEvents();
        showToast('Ocorrência atualizada.');
        return;
      }

      if (topAction === 'move_occurrence') {
        const occDate = isoOrDate(schedObj.occurrence_date);
        if (!occDate) { showToast('Data da ocorrência inválida para mover.', 'err'); return; }
        const ev = calendar.getEventById(schedObj.id);
        if (!ev || !ev.extendedProps?.rrule) { showToast('Evento recorrente não encontrado.', 'err'); return; }
        // Adicionar ao exdate
        const currentExdate = ev.extendedProps.exdate || '';
        const newExdate = currentExdate ? `${currentExdate},${toCompactDateTime(occDate)}` : toCompactDateTime(occDate);
        ev.setExtendedProp('exdate', newExdate);
        // Criar nova ocorrência simples na nova data/hora
        const newStart = isoOrDate(schedObj.new_start || schedObj.to);
        if (!newStart) { showToast('Nova data/hora inválida.', 'err'); return; }
        const duration = ev.end ? ev.end.getTime() - ev.start.getTime() : 60 * 60000;
        const newEnd = new Date(newStart.getTime() + duration);
        const created = addEvent({
          title: ev.title,
          start: newStart,
          end: newEnd,
          extendedProps: { location: ev.extendedProps.location, description: ev.extendedProps.description, acolytes: ev.extendedProps.acolytes }
        });
        saveEvents();
        showToast('Ocorrência movida.');
        return;
      }
    }

    function findEventsByIdOrTitle(id, title){
      if (id){
        const ev = calendar.getEventById(id);
        return ev ? [ev] : [];
      }
      if (title){
        return calendar.getEvents().filter(e => (e.title||'').toLowerCase().includes(String(title).toLowerCase()));
      }
      return [];
    }

    function parseIsoDurationToMinutes(iso){
      if (!iso || typeof iso !== 'string') return 0;
      const m = iso.match(/^PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?$/i);
      if (!m) return 0;
      const h = parseInt(m[1]||'0',10), mi = parseInt(m[2]||'0',10), s = parseInt(m[3]||'0',10);
      return h*60 + mi + Math.round(s/60);
    }

    function computeAvailability(av){
      const duration = Number(av.durationMinutes)||60;
      const start = av.windowStart ? new Date(av.windowStart) : new Date();
      const end   = av.windowEnd   ? new Date(av.windowEnd)   : new Date(start.getTime()+24*60*60000);

      const busy = calendar.getEvents()
        .map(e=>({ start: e.start, end: e.end || new Date(e.start.getTime()+60*60000) }))
        .filter(e=> e.start < end && e.end > start)
        .sort((a,b)=> a.start-b.start);

      // merge busy
      const merged=[];
      for(const b of busy){
        if(!merged.length || b.start>merged.at(-1).end) merged.push({start:new Date(b.start), end:new Date(b.end)});
        else merged.at(-1).end = new Date(Math.max(merged.at(-1).end, b.end));
      }

      const slots = [];
      let cur = new Date(start);
      const need = av.count || 3;

      // percorre da janela, pulando intervalos ocupados e enchendo com blocos de 'duration'
      while(cur < end && slots.length < need){
        // se 'cur' cai dentro de um ocupado, pula para o fim dele
        const hit = merged.find(b=> b.start <= cur && b.end > cur);
        if(hit){ cur = new Date(hit.end); continue; }

        // próximo ocupado à frente
        const next = merged.find(b=> b.start > cur) || { start: end };
        const freeEnd = new Date(Math.min(next.start, end));

        // preenche blocos contíguos de 'duration' nesse intervalo livre
        while(cur.getTime()+duration*60000 <= freeEnd.getTime() && slots.length < need){
          slots.push({ start: new Date(cur), end: new Date(cur.getTime()+duration*60000) });
          cur = new Date(cur.getTime()+duration*60000);
        }
        // se ainda há espaço mas não coube outro bloco completo, salta para o próximo ocupado
        if(cur < next.start) cur = new Date(next.end || next.start);
      }
      return slots;
    }

    // Função para gerar chave única de uma ação (para evitar duplicação)
    function getActionKey(obj) {
      if (!obj || typeof obj !== 'object') return null;
      
      const schedule = obj.schedule || obj;
      if (!schedule || typeof schedule !== 'object') return null;
      
      // Cria uma chave baseada nos campos principais da ação
      const keyParts = [
        schedule.action || obj.action || 'unknown',
        schedule.id || obj.id || '',
        schedule.title || obj.title || '',
        schedule.start || obj.start || '',
        schedule.rrule || obj.rrule || '', // Para eventos recorrentes
        schedule.location || obj.location || '',
        schedule.windowStart || obj.windowStart || '',
        schedule.windowEnd || obj.windowEnd || '',
        // Incluir acólitos para diferenciar missas com escalas diferentes
        JSON.stringify(schedule.acolytes || obj.acolytes || {})
      ];
      
      return keyParts.join('|').toLowerCase();
    }

    async function onSend(){
      const text = inputEl.value.trim();
      if (!text) return;
      inputEl.value = ''; inputEl.dispatchEvent(new Event('input'));

      pushUser(text);
      history.push({ role: 'user', content: text });
      session.history = history; session.updatedAt = Date.now(); SESS.save(session);

      sendBtn.disabled = true; sendBtn.textContent = 'Enviando…';

      const bubble = createBotStreamBubble();
      const actions = { schedules: [] }; // vamos preencher conforme cercas JSON fecharem
      let progressCtl = null;
      
      // Sistema unificado de deduplicação - compartilhado entre todas as fases
      const executedActions = new Set(); 
      const processedJsonStrings = new Set(); // Para evitar reprocessar mesmo JSON
      
      // Função para executar ação apenas se não foi executada
      const executeActionOnce = (obj, source = '') => {
        const actionKey = getActionKey(obj);
        if (actionKey && !executedActions.has(actionKey)) {
          console.log(`🔥 ${source}: Executing action:`, obj, 'with key:', actionKey);
          executedActions.add(actionKey);
          collectAction(obj, { schedules: actions.schedules, availability: [] });
          applyScheduleAction(obj);
          return true;
        } else {
          console.log(`🔥 ${source}: Skipping duplicate action:`, obj, 'key:', actionKey);
          return false;
        }
      };

      try {
        await streamCallGroq({
          onDelta: (visible) => {
            // Tenta extrair mensagem de objetos JSON top-level
            let displayText = visible;
            const topJson = extractTopLevelJson(visible);
            if (topJson) {
              const msg = extractMessagesFrom(topJson);
              if (msg) displayText = msg;
            }
            bubble.updateVisible(displayText);
          },
          onFence: (parsed) => {
            try {
              const items = flattenActions(parsed);
              if (!progressCtl && items.length) progressCtl = bubble.injectActionProgress();
              
              for (const obj of items){
                const executed = executeActionOnce(obj, 'onFence');
                if (executed && progressCtl) {
                  progressCtl.tick(Math.min(100, (actions.schedules.length / 1) * 100));
                }
              }
            } catch (err) {
              console.error('Erro ao processar ação JSON:', err);
              // Continua sem interromper o streaming
            }
          },
          onDone: ({ raw, sources }) => {
            if (progressCtl) { progressCtl.tick(100); setTimeout(()=>progressCtl.done(), 300); }
            // Fallback robusto: re-extrai ações do texto completo
            const parsed = splitVisibleFromActions(raw);
            const items = flattenActions(parsed.actions?.schedules?.length ? parsed.actions.schedules : parsed);
            for (const obj of items) {
              executeActionOnce(obj, 'onDone');
            }
            // Se o texto visível ficou vazio mas houve ação, gere uma confirmação curta
            let finalVisible = redactActionMentions(bubble.el.textContent.replace(/^[^\n]*\n/, ''));
            if (!finalVisible && (parsed.actions.schedules?.length || actions.schedules?.length)) {
              finalVisible = 'OK, ação registrada no calendário.';
              bubble.updateVisible(finalVisible);
            }
            
            // FALLBACK INTELIGENTE: Se AI não enviou JSON mas deveria ter enviado
            const totalActionsExecuted = actions.schedules?.length || 0;
            const hasResponseText = finalVisible && finalVisible.length > 5;
            
            if (hasResponseText && totalActionsExecuted === 0) {
              console.log('🔥 AI response without JSON detected, attempting smart fallback');
              
              // Tenta inferir ação baseada no texto da resposta
              const responseText = finalVisible.toLowerCase();
              let inferredAction = null;
              
              if (responseText.includes('criada') || responseText.includes('agendada') || responseText.includes('recorrente')) {
                // Detectou criação - mas precisaríamos de mais detalhes para criar JSON válido
                console.log('🔥 Detected creation response without JSON');
              } else if (responseText.includes('apagada') || responseText.includes('removida') || responseText.includes('excluída')) {
                inferredAction = {"schedule":{"action":"delete","id":"ALL"}};
              } else if (responseText.includes('listada') || responseText.includes('próximas')) {
                inferredAction = {"schedule":{"action":"list","days":14}};
              }
              
              if (inferredAction) {
                console.log('🔥 Executing inferred action:', inferredAction);
                executeActionOnce(inferredAction, 'smartFallback');
              }
            }
            history.push({ role: 'assistant', content: finalVisible || '(sem conteúdo)' });
            session.history = history; session.updatedAt = Date.now(); SESS.save(session);
            // Mostra os detalhes com o raw e TODAS as ações detectadas
            const allActs = { schedules: [...(actions.schedules||[]), ...(parsed.actions.schedules||[])] };
            bubble.attachDetails({ raw, actions: allActs, sources });
          }
        });
      } catch (err){
        console.error(err);
        showToast('Falha na chamada à API. Veja a mensagem no chat.', 'err');
        bubble.updateVisible(`Desculpe, houve um erro ao falar com a API.\n\nDetalhes: ${err.message}`);
      } finally {
        sendBtn.disabled = false; sendBtn.textContent = 'Enviar';
      }
    }

    // ======= Modal de opções =======
    const optionsBtn = document.getElementById('optionsBtn');
    const optionsModal = document.getElementById('optionsModal');
    const closeModalBtn = document.getElementById('closeModal');

    function openModal(){
      optionsModal.hidden = false;                  // <— remova o hidden
      optionsModal.classList.add('open');
      optionsModal.setAttribute('aria-hidden','false');
      document.body.style.overflow = 'hidden';      // evita scroll do fundo
      // Foco no primeiro campo
      const firstField = optionsModal.querySelector('input, select, button');
      if (firstField) firstField.focus();
    }

    function closeModal(){
      optionsModal.classList.remove('open');
      optionsModal.setAttribute('aria-hidden','true');
      optionsModal.hidden = true;                   // <— recoloca o hidden
      document.body.style.overflow = '';
      optionsBtn.focus(); // Retorna foco ao botão
    }

    optionsBtn.addEventListener('click', openModal);
    closeModalBtn.addEventListener('click', closeModal);
    optionsModal.addEventListener('click', (e) => {
      if (e.target === optionsModal) closeModal();
    });
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && optionsModal.classList.contains('open')) closeModal();
    });

    // ======= Utils =======
    function escapeHtml(s){ return (s||'').replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }
    function mdToHtml(s){
      const esc = escapeHtml(s || '');
      let out = esc.replace(/```([\s\S]*?)```/g, (m, code)=> `<pre><code>${code}</code></pre>`);
      out = out.replace(/`([^`]+)`/g,'<code class="inline">$1</code>');
      out = out
        .replace(/\*\*([^*]+)\*\*/g,'<strong>$1</strong>')
        .replace(/\*([^*]+)\*/g,'<em>$1</em>')
        .replace(/\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g,'<a target="_blank" href="$2">$1</a>')
        .replace(/\n/g,'<br/>');
      return out;
    }

    function missalMarkup(text, defaultMode = 'proclamation'){
      // Converte texto do usuário/assistente em blocos "Missal"
      const lines = String(text||'').split(/\r?\n/);
      const out = [];
      for (let raw of lines){
        if (!raw.trim()) continue;
        // Antífona "R/"
        if (/^(R\/|R:)\s*/i.test(raw)){
          out.push(`<p class="antiphon">${escapeHtml(raw.replace(/^(R\/|R:)\s*/i,''))}</p>`);
          continue;
        }
        // Rubricas explícitas
        if (/^rubrica\s*:/i.test(raw)){
          out.push(`<p class="rubric">${escapeHtml(raw.replace(/^rubrica\s*:\s*/i,''))}</p>`);
          continue;
        }
        // Por padrão, proclamação (ou rubrica se modo pedir)
        const cls = defaultMode === 'rubric' ? 'rubric' : 'proclamation';
        out.push(`<p class="${cls}">${escapeHtml(raw)}</p>`);
      }
      return out.join('\n');
    }

    function redactActionMentions(text){
      // Remove frases que "anunciam" JSON e qualquer cercado de ```
      let t = String(text||'');
      // Remove textos comuns de anúncio
      t = t.replace(/.*(segue|abaixo|comando|payload|json|código).*\n?/gi, '');
      // Remove todo conteúdo entre cercas de código
      t = t.replace(/```[\s\S]*?```/g, '');
      return t.trim();
    }

    bootThemeControls();
  </script>
</body>
</html>

